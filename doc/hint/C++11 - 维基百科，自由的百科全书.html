<!DOCTYPE html>
<html dir="ltr" class="client-js ve-not-available" lang="zh-CN"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title>C++11 - 维基百科，自由的百科全书</title>
<meta name="generator" content="MediaWiki 1.24wmf15">
<link rel="alternate" href="android-app://org.wikipedia/http/zh.m.wikipedia.org/wiki/C%2B%2B11">
<link rel="alternate" type="application/x-wiki" title="编辑本页" href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit">
<link rel="edit" title="编辑本页" href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit">
<link rel="apple-touch-icon" href="http://bits.wikimedia.org/apple-touch/wikipedia.png">
<link rel="shortcut icon" href="http://bits.wikimedia.org/favicon/wikipedia.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://zh.wikipedia.org/w/opensearch_desc.php" title="Wikipedia (zh)">
<link rel="EditURI" type="application/rsd+xml" href="http://zh.wikipedia.org/w/api.php?action=rsd">
<link rel="alternate" hreflang="zh" href="http://zh.wikipedia.org/zh/C%2B%2B11">
<link rel="alternate" hreflang="zh-Hans" href="http://zh.wikipedia.org/zh-hans/C%2B%2B11">
<link rel="alternate" hreflang="zh-Hant" href="http://zh.wikipedia.org/zh-hant/C%2B%2B11">
<link rel="alternate" hreflang="zh-CN" href="http://zh.wikipedia.org/zh-cn/C%2B%2B11">
<link rel="alternate" hreflang="zh-HK" href="http://zh.wikipedia.org/zh-hk/C%2B%2B11">
<link rel="alternate" hreflang="zh-MO" href="http://zh.wikipedia.org/zh-mo/C%2B%2B11">
<link rel="alternate" hreflang="zh-SG" href="http://zh.wikipedia.org/zh-sg/C%2B%2B11">
<link rel="alternate" hreflang="zh-TW" href="http://zh.wikipedia.org/zh-tw/C%2B%2B11">
<link rel="copyright" href="http://creativecommons.org/licenses/by-sa/3.0/">
<link rel="alternate" type="application/atom+xml" title="Wikipedia的Atom feed" href="http://zh.wikipedia.org/w/index.php?title=Special:%E6%9C%80%E8%BF%91%E6%9B%B4%E6%94%B9&amp;feed=atom">
<link rel="canonical" href="http://zh.wikipedia.org/wiki/C%2B%2B11">
<link rel="stylesheet" href="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/load_002.css">
<style>
@media print{#centralNotice{display:none}}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:ddb0c98a055632ae8e349c9cf48ac703 */
.tipsy{padding:5px;position:absolute;z-index:100000;cursor:default}.tipsy-inner{padding:5px 8px 4px 8px; background-color:#ffffff;border:solid 1px #a7d7f9;color:black;max-width:15em;border-radius:4px; }.tipsy-arrow{position:absolute;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALAgMAAADUwp+1AAAACVBMVEX5+fmn1/n///9s6BFKAAAAAXRSTlMAQObYZgAAACpJREFUCB1jZBD4wMiQMoeRcUU4I9uSaYxSE54xZjn8AtMgPkgcJA9UBwAeDw1Qrb3pVAAAAABJRU5ErkJggg==) no-repeat top left;background:url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.tipsy/images/tipsy.png?2014-07-24T17:18:20Z) no-repeat top left!ie;width:11px;height:6px} .tipsy-n .tipsy-arrow{top:0px;left:50%;margin-left:-5px} .tipsy-nw .tipsy-arrow{top:1px;left:10px} .tipsy-ne .tipsy-arrow{top:1px;right:10px} .tipsy-s .tipsy-arrow{bottom:0px;left:50%;margin-left:-5px;background-position:bottom left} .tipsy-sw .tipsy-arrow{bottom:0px;left:10px;background-position:bottom left} .tipsy-se .tipsy-arrow{bottom:0px;right:10px;background-position:bottom left} .tipsy-e .tipsy-arrow{top:50%;margin-top:-5px;right:1px;width:5px;height:11px;background-position:top right} .tipsy-w .tipsy-arrow{top:50%;margin-top:-5px;left:0px;width:6px;height:11px}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:51bac44d8e07e8f5805583c22617ee00 */
.uls-menu a{cursor:pointer}.uls-menu.callout .caret-before{border-top:20px solid transparent;border-right:20px solid #C9C9C9;border-bottom:20px solid transparent;display:inline-block;left:-21px;top:30px;position:absolute}.uls-menu.callout .caret-after{border-top:20px solid transparent;border-right:20px solid #FCFCFC;border-bottom:20px solid transparent;display:inline-block;left:-20px;top:30px;position:absolute}.uls-ui-languages button{width:23%;text-overflow:ellipsis;margin-right:4%}button.uls-more-languages{width:auto}.settings-title{font-size:11pt}.settings-text{color:#555555;font-size:9pt}div.display-settings-block:hover .settings-text{color:#252525}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:22d1681fa868b4ff4fbcb1ec1e58a9ea */
@-webkit-keyframes centralAuthPPersonalAnimation{0%{opacity:0;-webkit-transform:translateY(-20px)}100%{opacity:1;-webkit-transform:translateY(0)}}@-moz-keyframes centralAuthPPersonalAnimation{0%{opacity:0;-moz-transform:translateY(-20px)}100%{opacity:1;-moz-transform:translateY(0)}}@-o-keyframes centralAuthPPersonalAnimation{0%{opacity:0;-o-transform:translateY(-20px)}100%{opacity:1;-o-transform:translateY(0)}}@keyframes centralAuthPPersonalAnimation{0%{opacity:0;transform:translateY(-20px)}100%{opacity:1;transform:translateY(0)}}.centralAuthPPersonalAnimation{-webkit-animation-duration:1s;-moz-animation-duration:1s;-o-animation-duration:1s;animation-duration:1s;-webkit-animation-fill-mode:both;-moz-animation-fill-mode:both;-o-animation-fill-mode:both;animation-fill-mode:both;-webkit-animation-name:centralAuthPPersonalAnimation;-moz-animation-name:centralAuthPPersonalAnimation;-o-animation-name:centralAuthPPersonalAnimation;animation-name:centralAuthPPersonalAnimation}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:0dcacc990dd02e7db9669ab3090b80f1 */
.mw-editsection{white-space:nowrap; unicode-bidi:-moz-isolate;unicode-bidi:-webkit-isolate;unicode-bidi:isolate}.mw-editsection-divider{color:#555}.ve-tabmessage-appendix{font-size:0.7em;vertical-align:top;line-height:1.43em;padding-left:0.5em; background-image:none !important;display:inline !important}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:50c6a67a11952da7c9e5053046d794ee */</style><style>
.unihantooltip{position:absolute;list-style:none;list-style-image:none;opacity:0;font-size:small;margin:0;z-index:5;padding:0}.unihantooltip li{border:#080086 2px solid;max-width:260px;padding:10px 8px 13px 8px;margin:0px;background-color:#F7F7F7;box-shadow:2px 4px 2px rgba(0,0,0,0.3);-moz-box-shadow:2px 4px 2px rgba(0,0,0,0.3);-webkit-box-shadow:2px 4px 2px rgba(0,0,0,0.3)}.unihantooltip li+li{margin-left:7px;margin-top:-2px;border:0;padding:0;height:3px;width:0px;background-color:transparent;box-shadow:none;-moz-box-shadow:none;-webkit-box-shadow:none;border-top:12px #080086 solid;border-right:7px transparent solid;border-left:7px transparent solid}.unihantooltip>li+li::after{content:'';border-top:8px #F7F7F7 solid;border-right:5px transparent solid;border-left:5px transparent solid;margin-top:-12px;margin-left:-5px;z-index:1;height:0px;width:0px;display:block}.client-js body .unihantooltip li li{border:none;box-shadow:none;-moz-box-shadow:none;-webkit-box-shadow:none;height:auto;width:auto;margin:auto;padding:0;position:static}.UHflipped{padding-top:13px}.unihantooltip.UHflipped li+li{position:absolute;top:2px;border-top:0;border-bottom:12px #080086 solid}.unihantooltip.UHflipped li+li::after{border-top:0;border-bottom:8px #F7F7F7 solid;position:absolute;margin-top:7px}.UHsettings:hover{opacity:1;filter:alpha(opacity=100)}.UHTarget{border:#080086 2px solid}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:5ea41c78b0e56a2f106fd536795014b6 */</style><style>
.cite-accessibility-label{position:absolute !important; top:-99999px;clip:rect(1px 1px 1px 1px); clip:rect(1px,1px,1px,1px);padding:0 !important;border:0 !important;height:1px !important;width:1px !important;overflow:hidden}.mw-cite-backlink,.cite-accessibility-label{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:a59b70abe6ecaa39388bb79ebc509cb0 */
.topbottomScrollTag{position:fixed;left:0;padding:1px;color:#3366BB;font-size:small;width:1.25em;height:33%;text-align:center;-moz-opacity:0.3;filter:alpha(opacity=30);opacity:0.3}.topbottomScrollTag:hover{-moz-opacity:0.6;filter:alpha(opacity=60);opacity:0.6;cursor:pointer;background-color:#f0f0f0}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:166e17e51aefc84668a6283fa42120ce */
.referencetooltip{position:absolute;list-style:none;list-style-image:none;opacity:0;font-size:small;margin:0;z-index:5;padding:0}.referencetooltip li{border:#080086 2px solid;max-width:260px;padding:10px 8px 13px 8px;margin:0px;background-color:#F7F7F7;box-shadow:2px 4px 2px rgba(0,0,0,0.3);-moz-box-shadow:2px 4px 2px rgba(0,0,0,0.3);-webkit-box-shadow:2px 4px 2px rgba(0,0,0,0.3)}.referencetooltip li+li{margin-left:7px;margin-top:-2px;border:0;padding:0;height:3px;width:0px;background-color:transparent;box-shadow:none;-moz-box-shadow:none;-webkit-box-shadow:none;border-top:12px #080086 solid;border-right:7px transparent solid;border-left:7px transparent solid}.referencetooltip>li+li::after{content:'';border-top:8px #F7F7F7 solid;border-right:5px transparent solid;border-left:5px transparent solid;margin-top:-12px;margin-left:-5px;z-index:1;height:0px;width:0px;display:block}.client-js body .referencetooltip li li{border:none;box-shadow:none;-moz-box-shadow:none;-webkit-box-shadow:none;height:auto;width:auto;margin:auto;padding:0;position:static}.RTflipped{padding-top:13px}.referencetooltip.RTflipped li+li{position:absolute;top:2px;border-top:0;border-bottom:12px #080086 solid}.referencetooltip.RTflipped li+li::after{border-top:0;border-bottom:8px #F7F7F7 solid;position:absolute;margin-top:7px}.RTsettings{float:right;height:16px;width:16px;cursor:pointer;background-image:url(//upload.wikimedia.org/wikipedia/commons/e/ed/Cog.png);margin-top:-9px;margin-right:-7px;-webkit-transition:opacity 0.15s;-moz-transition:opacity 0.15s;-o-transition:opacity 0.15s;-ms-transition:opacity 0.15s;transition:opacity 0.15s;opacity:0.6;filter:alpha(opacity=60)}.RTsettings:hover{opacity:1;filter:alpha(opacity=100)}.RTTarget{border:#080086 2px solid}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:3b8525b5189198bb32b3970c580311a3 */
body.ltr .mw-editsection-expanded .mw-editsection-bracket:first-of-type,body.rtl .mw-editsection-expanded .mw-editsection-bracket:not(:first-of-type){margin-left:-0.25em;margin-right:0.25em;color:#555} body.rtl .mw-editsection-expanded .mw-editsection-bracket:first-of-type,body.ltr .mw-editsection-expanded .mw-editsection-bracket:not(:first-of-type){margin-right:-0.25em;margin-left:0.25em;color:#555}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:c33ab0089740bbd85318a51377a1995d */
li#ca-0,li#ca-1,li#ca-2,li#ca-varlang-0,li#ca-varlang-1,li#ca-varlang-2{display:none}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:21bc2b57d11c4d240c6275fe7e65cf82 */
.ilh-comment{display:none}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:a248514c17f0a2d0d49c2b9dc54a58c7 */
.ilh-tipsy .tipsy-inner{max-width:none}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:e6ba53d1e29f4142d84a8b4af4a5d269 */
.ilh-page a.new{color:#009999}.client-nojs .ilh-page a.new,.ilh-active .ilh-page a.new{color:#BA0000}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:6359e7eb8b206e925d8805291e1d7383 */
.noteTA-topicon{padding-left:0}.noteTA-topicon ul li.icon span a{background-image:url(//upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Zh_conversion_icon_m.svg/34px-Zh_conversion_icon_m.svg.png);width:46px;height:0;overflow:hidden;padding:3.1em 0 0;background-position:5px 75%}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:fb5d7b5e00784814d7a761f96b3ab37e */
div.Boxmerge,div.NavFrame{margin:0;padding:4px;border:1px solid #aaa;text-align:center;border-collapse:collapse;font-size:95%}div.NavContent{text-align:left}div.Boxmerge div.NavFrame,div.NavFrame + div.NavFrame,div.NavFrame + table.collapsible,table.collapsible + div.NavFrame,table.collapsible + table.collapsible{border-top-style:none;border-top-style:hidden}div.NavPic{background-color:#fff;margin:0;padding:2px; float:left}div.NavFrame div.NavHead{height:1.6em;font-weight:bold;background-color:#ccf;position:relative;cursor:pointer}div.NavFrame p,div.NavFrame div.NavContent,div.NavFrame div.NavContent p{font-size:100%}div.NavEnd{margin:0;padding:0;line-height:1px;clear:both}span.NavToggle{position:absolute;top:0; right:3px;font-weight:normal;font-size:90%}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:5ac6e73681ee7fe75ffa6bdcc4319736 */
#p-lang .uls-settings-trigger{background:transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAgCAMAAAAVMLmlAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAALpQTFRF////W1tbgICAWVlZgICAUVFRgICAWVlZhYWFUlJShYWFVFRUgYGBVVVVgYGBVVVVgICAVFRUVVVVVlZWgYGBgICAVFRUgYGBVFRUgICAgYGBVVVVVVVVgYGBVlZWgYGBVFRUgICAVFRUgICAVVVVgICAVlZWgICAVFRUgICAVVVVgICAVFRUgICAVlZWgICAVVVVgICAVVVVgICAVVVVgICAVVVVgICAVVVVgICAVVVVgICAVVVVgICA9Fa9bgAAADx0Uk5TAA4OFBQWFhcXGRlJSUtLWlpbXV9fYGFhZGRlZmlpa2twcIiIioqPj5GRn5+goKGh6+vv7/Dw+fn8/P7+YuRUVgAAAOlJREFUGBmNwcdWAgEURMFLFCUaAcWAEhQYHBRmCN3//1u+BYcVC6s4p2U3OLrrVxN7Xn7uELoH5w65Dx1g6JNnoLazfz++VnZehkZir4pQ3NjzBg5TwtgBhzFh6kDr294UobiykxZc7ezVdLyx8yrw6pM+8GjnDjsf7gj3/WpiJ7Vhl6OW3eC/mlKdo5teZSHNSoM24XqvTCHTvg0MdDIASpn08/6ZSlkJ6jMpLUBhLc3qKEwIIwUURoSJAs2ltC5AIZUWTbjcSulktJayCvCikx7wJG0VttrfEp5eLpfS4uLtgaOmVOeMP8BAM9RClMO9AAAAAElFTkSuQmCC) no-repeat right top;background:transparent url(//bits.wikimedia.org/static-1.24wmf15/extensions/UniversalLanguageSelector/resources/css/../images/cog-sprite.png?2014-07-24T17:21:40Z) no-repeat right top!ie;background-image:-webkit-linear-gradient(transparent,transparent),url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNCIgaGVpZ2h0PSIzMiI+PGRlZnM+PHBhdGggZD0iTTEzLjU4MiA2LjYzMmgtMS4wNjRjLS4xMzMtLjUzOC0uMzU0LTEuMDY1LS42NDUtMS41NTJsLjc1LS43NWMuMTY0LS4xNjQuMTY0LS40MjkgMC0uNTkzbC0xLjM1OS0xLjM2Yy0uMTY0LS4xNjQtLjQzLS4xNjQtLjU5NCAwbC0uNzUuNzVjLS40OS0uMjk0LTEuMDEyLS41MTItMS41NTEtLjY0NXYtMS4wNjRjMC0uMjMxLS4xODctLjQxOC0uNDE5LS40MThoLTEuOTE4Yy0uMjMxIDAtLjQxOC4xODctLjQxOC40MTh2MS4wNjNjLS41NDEuMTM1LTEuMDYyLjM1Mi0xLjU1Mi42NDZsLS43NS0uNzVjLS4xNjQtLjE2NC0uNDI5LS4xNjQtLjU5MyAwbC0xLjM2IDEuMzZjLS4xNjQuMTY0LS4xNjQuNDI5IDAgLjU5M2wuNzUuNzVjLS4yOTIuNDg4LS40OTQgMS4wMTUtLjYyNyAxLjU1MWgtMS4wNjRjLS4yMzEgMC0uNDE4LjE4Ny0uNDE4LjQxOXYxLjkxOGMwIC4yMzEuMTg3LjQxOC40MTguNDE4aDEuMDQ2Yy4xMzQuNTQyLjM1MSAxLjA2Mi42NDUgMS41NTFsLS43NS43NWMtLjE2NC4xNjQtLjE2NC40MjkgMCAuNTkzbDEuMzYgMS4zNmMuMTY0LjE2NC40MjkuMTY0LjU5MyAwbC43NS0uNzVjLjQ5MS4yOTYgMS4wMS40OTMgMS41NTEuNjI3djEuMDYzYy4wMDEuMjMzLjE4OC40Mi40MTkuNDJoMS45MThjLjIzMSAwIC40MTktLjE4Ny40MTktLjQxOHYtMS4wNjNjLjU0Mi0uMTM0IDEuMDYxLS4zMzMgMS41NTEtLjYyN2wuNzUuNzVjLjE2NC4xNjQuNDMuMTY0LjU5NCAwbDEuMzU5LTEuMzZjLjE2NC0uMTY0LjE2NC0uNDI5IDAtLjU5M2wtLjc1LS43NWMuMjk1LS40ODkuNTEtMS4wMTMuNjQ1LTEuNTUxaDEuMDY0Yy4yMy0uMDAyLjQxOC0uMTg5LjQxOC0uNDJ2LTEuOTE4YzAtLjIzMi0uMTg4LS40MTgtLjQxOC0uNDE4em0tNi41ODIgNC4wMTJjLTEuNDYxIDAtMi42NDUtMS4xODQtMi42NDUtMi42NDRzMS4xODQtMi42NDQgMi42NDUtMi42NDQgMi42NDUgMS4xODQgMi42NDUgMi42NDQtMS4xODQgMi42NDQtMi42NDUgMi42NDR6IiBpZD0iYSIvPjwvZGVmcz48dXNlIHhsaW5rOmhyZWY9IiNhIiBmaWxsPSIjODA4MDgwIi8+PHVzZSB4bGluazpocmVmPSIjYSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAxNikiIGZpbGw9IiM1NTUiLz48L3N2Zz4=);background-image:-webkit-linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.24wmf15/extensions/UniversalLanguageSelector/resources/css/../images/cog-sprite.svg?2014-07-24T17:21:40Z)!ie;background-image:linear-gradient(transparent,transparent),url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNCIgaGVpZ2h0PSIzMiI+PGRlZnM+PHBhdGggZD0iTTEzLjU4MiA2LjYzMmgtMS4wNjRjLS4xMzMtLjUzOC0uMzU0LTEuMDY1LS42NDUtMS41NTJsLjc1LS43NWMuMTY0LS4xNjQuMTY0LS40MjkgMC0uNTkzbC0xLjM1OS0xLjM2Yy0uMTY0LS4xNjQtLjQzLS4xNjQtLjU5NCAwbC0uNzUuNzVjLS40OS0uMjk0LTEuMDEyLS41MTItMS41NTEtLjY0NXYtMS4wNjRjMC0uMjMxLS4xODctLjQxOC0uNDE5LS40MThoLTEuOTE4Yy0uMjMxIDAtLjQxOC4xODctLjQxOC40MTh2MS4wNjNjLS41NDEuMTM1LTEuMDYyLjM1Mi0xLjU1Mi42NDZsLS43NS0uNzVjLS4xNjQtLjE2NC0uNDI5LS4xNjQtLjU5MyAwbC0xLjM2IDEuMzZjLS4xNjQuMTY0LS4xNjQuNDI5IDAgLjU5M2wuNzUuNzVjLS4yOTIuNDg4LS40OTQgMS4wMTUtLjYyNyAxLjU1MWgtMS4wNjRjLS4yMzEgMC0uNDE4LjE4Ny0uNDE4LjQxOXYxLjkxOGMwIC4yMzEuMTg3LjQxOC40MTguNDE4aDEuMDQ2Yy4xMzQuNTQyLjM1MSAxLjA2Mi42NDUgMS41NTFsLS43NS43NWMtLjE2NC4xNjQtLjE2NC40MjkgMCAuNTkzbDEuMzYgMS4zNmMuMTY0LjE2NC40MjkuMTY0LjU5MyAwbC43NS0uNzVjLjQ5MS4yOTYgMS4wMS40OTMgMS41NTEuNjI3djEuMDYzYy4wMDEuMjMzLjE4OC40Mi40MTkuNDJoMS45MThjLjIzMSAwIC40MTktLjE4Ny40MTktLjQxOHYtMS4wNjNjLjU0Mi0uMTM0IDEuMDYxLS4zMzMgMS41NTEtLjYyN2wuNzUuNzVjLjE2NC4xNjQuNDMuMTY0LjU5NCAwbDEuMzU5LTEuMzZjLjE2NC0uMTY0LjE2NC0uNDI5IDAtLjU5M2wtLjc1LS43NWMuMjk1LS40ODkuNTEtMS4wMTMuNjQ1LTEuNTUxaDEuMDY0Yy4yMy0uMDAyLjQxOC0uMTg5LjQxOC0uNDJ2LTEuOTE4YzAtLjIzMi0uMTg4LS40MTgtLjQxOC0uNDE4em0tNi41ODIgNC4wMTJjLTEuNDYxIDAtMi42NDUtMS4xODQtMi42NDUtMi42NDRzMS4xODQtMi42NDQgMi42NDUtMi42NDQgMi42NDUgMS4xODQgMi42NDUgMi42NDQtMS4xODQgMi42NDQtMi42NDUgMi42NDR6IiBpZD0iYSIvPjwvZGVmcz48dXNlIHhsaW5rOmhyZWY9IiNhIiBmaWxsPSIjODA4MDgwIi8+PHVzZSB4bGluazpocmVmPSIjYSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCAxNikiIGZpbGw9IiM1NTUiLz48L3N2Zz4=);background-image:linear-gradient(transparent,transparent),url(//bits.wikimedia.org/static-1.24wmf15/extensions/UniversalLanguageSelector/resources/css/../images/cog-sprite.svg?2014-07-24T17:21:40Z)!ie;height:16px;width:14px;float:right;cursor:pointer}.skin-vector #p-lang .uls-settings-trigger{ margin-top:3px}#p-lang .uls-settings-trigger:hover{background-position:right -16px}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:e35dd88acdd30f5be0eff579b3711b98 */
.mw-collapsible-toggle{float:right;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.mw-customtoggle,.mw-collapsible-toggle{cursor:pointer} caption .mw-collapsible-toggle{float:none} li .mw-collapsible-toggle{float:none} .mw-collapsible-toggle-li{list-style:none}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:869aa9133c31e6040d4830b259da96a8 */
.suggestions{overflow:hidden;position:absolute;top:0;left:0;width:0;border:none;z-index:1099;padding:0;margin:-1px -1px 0 0} html > body .suggestions{margin:-1px 0 0 0}.suggestions-special{position:relative;background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0;margin-top:-2px;display:none;padding:0.25em 0.25em;line-height:1.25em}.suggestions-results{background-color:white;cursor:pointer;border:solid 1px #aaaaaa;padding:0;margin:0}.suggestions-result{color:black;margin:0;line-height:1.5em;padding:0.01em 0.25em;text-align:left; overflow:hidden;-o-text-overflow:ellipsis; text-overflow:ellipsis;white-space:nowrap}.suggestions-result-current{background-color:#4C59A6;color:white}.suggestions-special .special-label{color:gray;text-align:left}.suggestions-special .special-query{color:black;font-style:italic;text-align:left}.suggestions-special .special-hover{background-color:silver}.suggestions-result-current .special-label,.suggestions-result-current .special-query{color:white}.highlight{font-weight:bold}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:9f9511aa4ef920d34591113e825e6a1e */
.postedit-container{margin:0 auto;position:fixed;top:0;height:0;left:50%;z-index:1000;font-size:13px}.postedit-container:hover{cursor:pointer}.postedit{position:relative;top:0.6em;left:-50%;padding:.6em 3.6em .6em 1.1em;line-height:1.5625em;color:#626465;background-color:#f4f4f4;border:1px solid #dcd9d9;text-shadow:0 0.0625em 0 rgba(255,255,255,0.5);border-radius:5px;box-shadow:0 2px 5px 0 #ccc;-webkit-transition:all 0.25s ease-in-out;-moz-transition:all 0.25s ease-in-out;-ms-transition:all 0.25s ease-in-out;-o-transition:all 0.25s ease-in-out;transition:all 0.25s ease-in-out}.skin-monobook .postedit{top:6em !important}.postedit-faded{opacity:0}.postedit-icon{padding-left:41px;  line-height:25px;background-repeat:no-repeat;background-position:8px 50%}.postedit-icon-checkmark{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABblBMVEUAAAD///////9PfTf///80aRdTgjn///9Feij///////////9Rfzf///////////9PfjZRgDh1o1xOfTb///////+bwYqLtnj///////9PfTa82K////9WhT6YxIL///9QgDdTgzr////////j7uDl7eLq8efi693k7OH///////9UhjuBr2rp9uRUhjr///9YljVKgir///9WiTlYjT3////9/v57vFlbkT5PjC9dlD/5/fhuq09stUTs9uhxuElctCpfnT1huDFloEZloUZmpENmvDZpvDxpvTxqvjxrvT5rvT9rwTxsqktswD5uwkBvuUdxw0NztFBztU9ztVBzwkp0tlJ1xkd2t1R3uVR4w1F4xk54x014yE15uVZ5v1R5xVB6v1R7yFJ8wVh9xVl9yFR9yVd9ylN+xVh+yFd/x1l/yFeAylmEx1+Ny2uY0Hqe04Wj1Ymv3Ze33qLD47TJ5L3O6cPU7Mrq9eb2+/Q4j37OAAAAQHRSTlMAAQIEBAUFBQwPFB4fJCUoKiosQEhJS01RUlZZXmdydXaChYuSlJSWmJmoq6uur8LExcvM19fg5ejt8fX2+Pr7SljgewAAAKpJREFUGBkFwQNCAwAAAMDLtl3LtrG4rWXbtvX77gAgZ6grFwC0bhwNVgKgdPZx8b0dgLi+s7Wn0VoAqpfOI9+BNADZI7fLrz2pSEwGHZuH+78lSK8ZLkLezF3ooyUG3VPXq2USei9WngeyoG195yBYWDF3E/2pAhl1e9Gr8bGT+bfOFCC2fnvh4X7rcqIAQNNu+HT6sxkAjceTL/2ZAIhv+PorBwBJxfkA//dFHSCBy/UTAAAAAElFTkSuQmCC);background-image:url(//bits.wikimedia.org/static-1.24wmf15/resources/src/mediawiki.action/images/green-checkmark.png?2014-07-24T17:18:20Z)!ie;background-position:left}.postedit-close{position:absolute;padding:0 .8em;right:0;top:0;font-size:1.25em;font-weight:bold;line-height:2.3em;color:black;text-shadow:0 0.0625em 0 white;text-decoration:none;opacity:0.2;filter:alpha(opacity=20)}.postedit-close:hover{color:black;text-decoration:none;opacity:0.4;filter:alpha(opacity=40)}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:e4278e03cfe31fd402289d7b127426f6 */
.mw-mmv-overlay{position:fixed;top:0px;left:0px;right:0px;bottom:0px;z-index:1000;background-color:#000000}body.mw-mmv-lightbox-open{overflow-y:auto}body.mw-mmv-lightbox-open #mw-page-base,body.mw-mmv-lightbox-open #mw-head-base,body.mw-mmv-lightbox-open #mw-navigation,body.mw-mmv-lightbox-open #content,body.mw-mmv-lightbox-open #footer,body.mw-mmv-lightbox-open #globalWrapper // monobook{ display:none}body.mw-mmv-lightbox-open > *{ display:none}body.mw-mmv-lightbox-open > .mw-mmv-overlay,body.mw-mmv-lightbox-open > .mw-mmv-wrapper{display:block}.mw-mmv-view-expanded{display:inline-block;border:1px solid #dddddd;padding:5px 10px;padding-left:35px;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE3LjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIKCSBpZD0iTGF5ZXJfMSIgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCgkgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCA5MDAuNCA3NjgiCgkgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgOTAwLjQgNzY4IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8cG9seWdvbiBmaWxsPSIjNzc3Nzc3IiBwb2ludHM9IjU5OS45LDE4Ni40IDYzMS4xLDIxNy42IDU0NS41LDMwMy4yIDUyNC4xLDI4MS43IDUxOSwzNjkuNiA2MDYuOSwzNjQuNiA1ODUuNCwzNDMuMSA2NzEsMjU3LjUgCgkJNzAyLjIsMjg4LjcgNzA5LjIsMTc5LjQgCSIvPgoJPHBvbHlnb24gZmlsbD0iIzc3Nzc3NyIgcG9pbnRzPSI1NDUuNSwyNjguOCA1ODcuNiwyMjcgNTAzLjUsMjI3IDU0MS4zLDI2NC44IAkiLz4KCTxwYXRoIGZpbGw9IiM3Nzc3NzciIGQ9Ik01MjAuNCwzOTMuOWwtMjcuMywxLjZsMS42LTI3LjNsNS04Ny43bDMuMS01My41SDE5MS4ydjM2Mmg0NzFWMzg1LjhsLTUzLjgsMy4xTDUyMC40LDM5My45eiBNNjExLjIsNTQxCgkJSDIzNy43bDExMC41LTE0NC4xTDM2NSwzOTBsMTA0LjQsMTA5LjNsNTYuNS0zMy43bDg1LjIsNzUuMUw2MTEuMiw1NDFMNjExLjIsNTQxeiIvPgoJPHBvbHlnb24gZmlsbD0iIzc3Nzc3NyIgcG9pbnRzPSI2MjQuMiwzNDcuMyA2NjIuMiwzODUuMyA2NjIuMiwzMDEgNjIwLDM0My4xIAkiLz4KPC9nPgo8L3N2Zz4K);background-image:url(//bits.wikimedia.org/static-1.24wmf15/extensions/MultimediaViewer/resources/mmv/img/expand.svg?2014-07-24T17:20:00Z)!ie;background-position:left;background-repeat:no-repeat}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:db3bb272f4353febe1e83f52e1d023fd */</style><style>
.suggestions a.mw-searchSuggest-link,.suggestions a.mw-searchSuggest-link:hover,.suggestions a.mw-searchSuggest-link:active,.suggestions a.mw-searchSuggest-link:focus{color:black;text-decoration:none}.suggestions-result-current a.mw-searchSuggest-link,.suggestions-result-current a.mw-searchSuggest-link:hover,.suggestions-result-current a.mw-searchSuggest-link:active,.suggestions-result-current a.mw-searchSuggest-link:focus{color:white}.suggestions a.mw-searchSuggest-link .special-query{ overflow:hidden;-o-text-overflow:ellipsis; text-overflow:ellipsis;white-space:nowrap}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:ae3fa4570b5ac0c6cf7b3776c8ae4d6f */</style><style>
.ui-helper-hidden{display:none}.ui-helper-hidden-accessible{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.ui-helper-reset{margin:0;padding:0;border:0;outline:0;line-height:1.3;text-decoration:none;font-size:100%;list-style:none}.ui-helper-clearfix:before,.ui-helper-clearfix:after{content:"";display:table}.ui-helper-clearfix:after{clear:both}.ui-helper-clearfix{zoom:1}.ui-helper-zfix{width:100%;height:100%;top:0;left:0;position:absolute;opacity:0;filter:Alpha(Opacity=0)} .ui-state-disabled{cursor:default !important}  .ui-icon{display:block;text-indent:-99999px;overflow:hidden;background-repeat:no-repeat}  .ui-widget-overlay{position:absolute;top:0;left:0;width:100%;height:100%}  .ui-widget{font-family:sans-serif;font-size:0.8em}.ui-widget .ui-widget{font-size:1em}.ui-widget input,.ui-widget select,.ui-widget textarea,.ui-widget button{font-family:sans-serif;font-size:1em}.ui-widget-content{border:1px solid #cccccc;background:#f2f5f7 url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAYAAABHLFpgAAAAKElEQVQYV2P6+ev3fyYGIBiGxH8w6/9/GAsshuD+Byv5D2dhKh6eBAAABBSmkTpaYQAAAABJRU5ErkJggg==) 50% top repeat-x;background:#f2f5f7 url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-bg_highlight-hard_100_f2f5f7_1x100.png?2014-07-29T23:30:00Z) 50% top repeat-x!ie;color:#362b36}.ui-widget-header{border-bottom:1px solid #bbbbbb;line-height:1em;background:#ffffff url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAYAAABHLFpgAAAAF0lEQVQYV2P49+/ff4ZhQPwHglGCKAIAdlSOCIOoOV0AAAAASUVORK5CYII=) 50% 50% repeat-x;background:#ffffff url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-bg_highlight-soft_100_ffffff_1x100.png?2014-07-29T23:30:00Z) 50% 50% repeat-x!ie;color:#222222;font-weight:bold} .ui-state-default,.ui-widget-content .ui-state-default,.ui-widget-header .ui-state-default{border:1px solid #aed0ea;background:#d7ebf9 url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAYAAABHLFpgAAAAL0lEQVQY02N69eXPfyYGIBhexH+G/0DiP5gFJP79RxAwiX9giX//kZUgdDAMXwIA/14cgwH0gmgAAAAASUVORK5CYII=) 50% 50% repeat-x;background:#d7ebf9 url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-bg_highlight-hard_80_d7ebf9_1x100.png?2014-07-29T23:30:00Z) 50% 50% repeat-x!ie;font-weight:normal;color:#2779aa}.ui-state-default a,.ui-state-default a:link,.ui-state-default a:visited{color:#2779aa;text-decoration:none}.ui-state-hover,.ui-widget-content .ui-state-hover,.ui-widget-header .ui-state-hover,.ui-state-focus,.ui-widget-content .ui-state-focus,.ui-widget-header .ui-state-focus{border:1px solid #74b2e2;background:#e4f1fb url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAYAAABHLFpgAAAAMUlEQVQYV2P68vPvfyYGIBhCxP//cBacYAAKInGRlIBYaBJQHWAWXBuqoVBZmNhwIgBlYh6Ywkr41gAAAABJRU5ErkJggg==) 50% 50% repeat-x;background:#e4f1fb url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-bg_highlight-soft_100_e4f1fb_1x100.png?2014-07-29T23:30:00Z) 50% 50% repeat-x!ie;font-weight:normal;color:#0070a3}.ui-state-hover a,.ui-state-hover a:hover{color:#0070a3;text-decoration:none}.ui-state-active,.ui-widget-content .ui-state-active,.ui-widget-header .ui-state-active{border:1px solid #cccccc;background:#f0f0f0 url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAYAAABHLFpgAAAAIElEQVQYV2P68OHDfyYGIBiuBCMjIzILGxdNDI017AgARXMEsCkUdugAAAAASUVORK5CYII=) 50% 50% repeat-x;background:#f0f0f0 url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-bg_inset-hard_100_f0f0f0_1x100.png?2014-07-29T23:30:00Z) 50% 50% repeat-x!ie;font-weight:normal;color:#000000}.ui-state-active a,.ui-state-active a:link,.ui-state-active a:visited{color:#000000;text-decoration:none}.ui-widget :active{outline:none} .ui-state-highlight,.ui-widget-content .ui-state-highlight,.ui-widget-header .ui-state-highlight{border:1px solid #f9dd34;background:#ffef8f url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAYAAAEwK2r2AAAAX0lEQVQYV2P+/3HBf+aGyoAGTMK3gbm+3B1IVLgCuRUe2AlsBtRX+oG0eYEMcAOpcyNeLx4CbKgP3GRPEAtssjse95HkcOoQUO/7obrZG+rwBrjrGyo8oa6vJ88L5BEAeRC4pmqV01IAAAAASUVORK5CYII=) 50% top repeat-x;background:#ffef8f url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-bg_highlight-soft_25_ffef8f_1x100.png?2014-07-29T23:30:00Z) 50% top repeat-x!ie;color:#363636}.ui-state-highlight a,.ui-widget-content .ui-state-highlight a,.ui-widget-header .ui-state-highlight a{color:#363636}.ui-state-error,.ui-widget-content .ui-state-error,.ui-widget-header .ui-state-error{border:1px solid #cd0a0a;background:#cd0a0a url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAABkAQMAAADOquA5AAAAA1BMVEXNCgokNzldAAAAD0lEQVQoFWNgGAWjgPoAAAJYAAEDeXiTAAAAAElFTkSuQmCC) 50% 50% repeat-x;background:#cd0a0a url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-bg_flat_15_cd0a0a_40x100.png?2014-07-29T23:30:00Z) 50% 50% repeat-x!ie;color:#ffffff}.ui-state-error a,.ui-widget-content .ui-state-error a,.ui-widget-header .ui-state-error a{color:#ffffff}.ui-state-error-text,.ui-widget-content .ui-state-error-text,.ui-widget-header .ui-state-error-text{color:#ffffff}.ui-priority-primary,.ui-widget-content .ui-priority-primary,.ui-widget-header .ui-priority-primary{font-weight:bold}.ui-priority-secondary,.ui-widget-content .ui-priority-secondary,.ui-widget-header .ui-priority-secondary{opacity:.7;filter:Alpha(Opacity=70);font-weight:normal}.ui-state-disabled,.ui-widget-content .ui-state-disabled,.ui-widget-header .ui-state-disabled{opacity:.35;filter:Alpha(Opacity=35);background-image:none}  .ui-icon{width:16px;height:16px}.ui-icon,.ui-widget-content .ui-icon,.ui-widget-header .ui-icon{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAADwCAMAAADYSUr5AAAA7VBMVEV0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psx0psyPQTyXAAAATnRSTlMAGBAyBAhQv4OZLiJUcEBmYBoSzQwgPBZCSEoeWiYwUiyFNIeBw2rJz8c4RBy9uXyrtaWNqa2zKP2fJO8KBgKPo2KVoa9s351GPm5+kWho0kj9AAAM6klEQVR4XuybAYrjMAxFrRzw3f84C2F2g+ex34Q0NKV6sCzNl2xLVpy47own0DRNUV8ePw/PAHU5xChSUJMx9cYKBGAy0ATBL7VA6kGBOpD/ZAz1vgoEQHPkBHgGrdrdHdhYLrfg8ccQgl5ABe/QuoFSj/cC5QBdAblCPMOxAsIAVAFvwUNUfCIYFCzSC6U14DueAr6FdmOqX4Sapmmapmm+4k2wHvUi5t0OVAiIHZSv/H1A+EKoUBO34gEoATaYzScD5avcHBU3j2riBjz+POIgF1AhXzGfBtj/3Y0r+KDSiMvmDrhSPmUeKuBNFHd+H+A7xGtAPwW+gqZpmqZpGq55A1xqn/cGMIB4weJJONe/E4o+WI8esX0GNpndsZY60ACkrvvP8SBZutQQgbvjl4jEWEFywGLuP26XcQKCzE6OILnHAThAdmYDZnN21P+JFOUShlV+HTHZ3QM418OJ8KzaAHQh60Ng/1zQoUPLvpRVxkV4qH9+TDZN0zRN01z/WSpcHkDcL2aNnRHIasG5AYQOZBUjyAOYj5WoScpQaQONj/chbjCX/ctdAUjLAwCYDxahJi1WEFRMQKm7dZnFDECMH4m6YncOkSlFjFBB3g47wfgKYz0ApKoBjVD+0uVvGTUwQoBKgBK0ToAGIHsZrGWI++dhd98CoYuRboGCOnMLuMbdP2ERwwEIT5kk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);background-image:url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-icons_72a7cf_256x240.png?2014-07-29T23:30:00Z)!ie}.ui-state-default .ui-icon{background-image:url(data:image/png;base64,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);background-image:url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-icons_3d80b3_256x240.png?2014-07-29T23:30:00Z)!ie}.ui-state-hover .ui-icon,.ui-state-focus .ui-icon{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAADwCAMAAADYSUr5AAAA7VBMVEUkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwkluwOSETqAAAATnRSTlMAGBAyBAhQv4OZLiJUcEBmYBoSzQwgPBZCSEoeWiYwUiyFNIeBw2rJz8c4RBy9uXyrtaWNqa2zKP2fJO8KBgKPo2KVoa9s351GPm5+kWho0kj9AAAM6klEQVR4XuybAYrjMAxFrRzw3f84C2F2g+ex34Q0NKV6sCzNl2xLVpy47own0DRNUV8ePw/PAHU5xChSUJMx9cYKBGAy0ATBL7VA6kGBOpD/ZAz1vgoEQHPkBHgGrdrdHdhYLrfg8ccQgl5ABe/QuoFSj/cC5QBdAblCPMOxAsIAVAFvwUNUfCIYFCzSC6U14DueAr6FdmOqX4Sapmmapmm+4k2wHvUi5t0OVAiIHZSv/H1A+EKoUBO34gEoATaYzScD5avcHBU3j2riBjz+POIgF1AhXzGfBtj/3Y0r+KDSiMvmDrhSPmUeKuBNFHd+H+A7xGtAPwW+gqZpmqZpGq55A1xqn/cGMIB4weJJONe/E4o+WI8esX0GNpndsZY60ACkrvvP8SBZutQQgbvjl4jEWEFywGLuP26XcQKCzE6OILnHAThAdmYDZnN21P+JFOUShlV+HTHZ3QM418OJ8KzaAHQh60Ng/1zQoUPLvpRVxkV4qH9+TDZN0zRN01z/WSpcHkDcL2aNnRHIasG5AYQOZBUjyAOYj5WoScpQaQONj/chbjCX/ctdAUjLAwCYDxahJi1WEFRMQKm7dZnFDECMH4m6YncOkSlFjFBB3g47wfgKYz0ApKoBjVD+0uVvGTUwQoBKgBK0ToAGIHsZrGWI++dhd98CoYuRboGCOnMLuMbdP2ERwwEIT5kk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);background-image:url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-icons_2694e8_256x240.png?2014-07-29T23:30:00Z)!ie}.ui-state-active .ui-icon{background-image:url(data:image/png;base64,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);background-image:url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-icons_666666_256x240.png?2014-07-29T23:30:00Z)!ie}.ui-state-highlight .ui-icon{background-image:url(data:image/png;base64,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);background-image:url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-icons_2e83ff_256x240.png?2014-07-24T17:18:20Z)!ie}.ui-state-error .ui-icon,.ui-state-error-text .ui-icon{background-image:url(data:image/png;base64,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);background-image:url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-icons_ffffff_256x240.png?2014-07-29T23:30:00Z)!ie} .ui-icon-carat-1-n{background-position:0 0}.ui-icon-carat-1-ne{background-position:-16px 0}.ui-icon-carat-1-e{background-position:-32px 0}.ui-icon-carat-1-se{background-position:-48px 0}.ui-icon-carat-1-s{background-position:-64px 0}.ui-icon-carat-1-sw{background-position:-80px 0}.ui-icon-carat-1-w{background-position:-96px 0}.ui-icon-carat-1-nw{background-position:-112px 0}.ui-icon-carat-2-n-s{background-position:-128px 0}.ui-icon-carat-2-e-w{background-position:-144px 0}.ui-icon-triangle-1-n{background-position:0 -16px}.ui-icon-triangle-1-ne{background-position:-16px -16px}.ui-icon-triangle-1-e{background-position:-32px -16px}.ui-icon-triangle-1-se{background-position:-48px -16px}.ui-icon-triangle-1-s{background-position:-64px -16px}.ui-icon-triangle-1-sw{background-position:-80px -16px}.ui-icon-triangle-1-w{background-position:-96px -16px}.ui-icon-triangle-1-nw{background-position:-112px -16px}.ui-icon-triangle-2-n-s{background-position:-128px -16px}.ui-icon-triangle-2-e-w{background-position:-144px -16px}.ui-icon-arrow-1-n{background-position:0 -32px}.ui-icon-arrow-1-ne{background-position:-16px -32px}.ui-icon-arrow-1-e{background-position:-32px -32px}.ui-icon-arrow-1-se{background-position:-48px -32px}.ui-icon-arrow-1-s{background-position:-64px -32px}.ui-icon-arrow-1-sw{background-position:-80px -32px}.ui-icon-arrow-1-w{background-position:-96px -32px}.ui-icon-arrow-1-nw{background-position:-112px -32px}.ui-icon-arrow-2-n-s{background-position:-128px -32px}.ui-icon-arrow-2-ne-sw{background-position:-144px -32px}.ui-icon-arrow-2-e-w{background-position:-160px -32px}.ui-icon-arrow-2-se-nw{background-position:-176px -32px}.ui-icon-arrowstop-1-n{background-position:-192px -32px}.ui-icon-arrowstop-1-e{background-position:-208px -32px}.ui-icon-arrowstop-1-s{background-position:-224px -32px}.ui-icon-arrowstop-1-w{background-position:-240px -32px}.ui-icon-arrowthick-1-n{background-position:0 -48px}.ui-icon-arrowthick-1-ne{background-position:-16px -48px}.ui-icon-arrowthick-1-e{background-position:-32px -48px}.ui-icon-arrowthick-1-se{background-position:-48px -48px}.ui-icon-arrowthick-1-s{background-position:-64px -48px}.ui-icon-arrowthick-1-sw{background-position:-80px -48px}.ui-icon-arrowthick-1-w{background-position:-96px -48px}.ui-icon-arrowthick-1-nw{background-position:-112px -48px}.ui-icon-arrowthick-2-n-s{background-position:-128px -48px}.ui-icon-arrowthick-2-ne-sw{background-position:-144px -48px}.ui-icon-arrowthick-2-e-w{background-position:-160px -48px}.ui-icon-arrowthick-2-se-nw{background-position:-176px -48px}.ui-icon-arrowthickstop-1-n{background-position:-192px -48px}.ui-icon-arrowthickstop-1-e{background-position:-208px -48px}.ui-icon-arrowthickstop-1-s{background-position:-224px -48px}.ui-icon-arrowthickstop-1-w{background-position:-240px -48px}.ui-icon-arrowreturnthick-1-w{background-position:0 -64px}.ui-icon-arrowreturnthick-1-n{background-position:-16px -64px}.ui-icon-arrowreturnthick-1-e{background-position:-32px -64px}.ui-icon-arrowreturnthick-1-s{background-position:-48px -64px}.ui-icon-arrowreturn-1-w{background-position:-64px -64px}.ui-icon-arrowreturn-1-n{background-position:-80px -64px}.ui-icon-arrowreturn-1-e{background-position:-96px -64px}.ui-icon-arrowreturn-1-s{background-position:-112px -64px}.ui-icon-arrowrefresh-1-w{background-position:-128px -64px}.ui-icon-arrowrefresh-1-n{background-position:-144px -64px}.ui-icon-arrowrefresh-1-e{background-position:-160px -64px}.ui-icon-arrowrefresh-1-s{background-position:-176px -64px}.ui-icon-arrow-4{background-position:0 -80px}.ui-icon-arrow-4-diag{background-position:-16px -80px}.ui-icon-extlink{background-position:-32px -80px}.ui-icon-newwin{background-position:-48px -80px}.ui-icon-refresh{background-position:-64px -80px}.ui-icon-shuffle{background-position:-80px -80px}.ui-icon-transfer-e-w{background-position:-96px -80px}.ui-icon-transferthick-e-w{background-position:-112px -80px}.ui-icon-folder-collapsed{background-position:0 -96px}.ui-icon-folder-open{background-position:-16px -96px}.ui-icon-document{background-position:-32px -96px}.ui-icon-document-b{background-position:-48px -96px}.ui-icon-note{background-position:-64px -96px}.ui-icon-mail-closed{background-position:-80px -96px}.ui-icon-mail-open{background-position:-96px -96px}.ui-icon-suitcase{background-position:-112px -96px}.ui-icon-comment{background-position:-128px -96px}.ui-icon-person{background-position:-144px -96px}.ui-icon-print{background-position:-160px -96px}.ui-icon-trash{background-position:-176px -96px}.ui-icon-locked{background-position:-192px -96px}.ui-icon-unlocked{background-position:-208px -96px}.ui-icon-bookmark{background-position:-224px -96px}.ui-icon-tag{background-position:-240px -96px}.ui-icon-home{background-position:0 -112px}.ui-icon-flag{background-position:-16px -112px}.ui-icon-calendar{background-position:-32px -112px}.ui-icon-cart{background-position:-48px -112px}.ui-icon-pencil{background-position:-64px -112px}.ui-icon-clock{background-position:-80px -112px}.ui-icon-disk{background-position:-96px -112px}.ui-icon-calculator{background-position:-112px -112px}.ui-icon-zoomin{background-position:-128px -112px}.ui-icon-zoomout{background-position:-144px -112px}.ui-icon-search{background-position:-160px -112px}.ui-icon-wrench{background-position:-176px -112px}.ui-icon-gear{background-position:-192px -112px}.ui-icon-heart{background-position:-208px -112px}.ui-icon-star{background-position:-224px -112px}.ui-icon-link{background-position:-240px -112px}.ui-icon-cancel{background-position:0 -128px}.ui-icon-plus{background-position:-16px -128px}.ui-icon-plusthick{background-position:-32px -128px}.ui-icon-minus{background-position:-48px -128px}.ui-icon-minusthick{background-position:-64px -128px}.ui-icon-close{background-position:-80px -128px}.ui-icon-closethick{background-position:-96px -128px}.ui-icon-key{background-position:-112px -128px}.ui-icon-lightbulb{background-position:-128px -128px}.ui-icon-scissors{background-position:-144px -128px}.ui-icon-clipboard{background-position:-160px -128px}.ui-icon-copy{background-position:-176px -128px}.ui-icon-contact{background-position:-192px -128px}.ui-icon-image{background-position:-208px -128px}.ui-icon-video{background-position:-224px -128px}.ui-icon-script{background-position:-240px -128px}.ui-icon-alert{background-position:0 -144px}.ui-icon-info{background-position:-16px -144px}.ui-icon-notice{background-position:-32px -144px}.ui-icon-help{background-position:-48px -144px}.ui-icon-check{background-position:-64px -144px}.ui-icon-bullet{background-position:-80px -144px}.ui-icon-radio-off{background-position:-96px -144px}.ui-icon-radio-on{background-position:-112px -144px}.ui-icon-pin-w{background-position:-128px -144px}.ui-icon-pin-s{background-position:-144px -144px}.ui-icon-play{background-position:0 -160px}.ui-icon-pause{background-position:-16px -160px}.ui-icon-seek-next{background-position:-32px -160px}.ui-icon-seek-prev{background-position:-48px -160px}.ui-icon-seek-end{background-position:-64px -160px}.ui-icon-seek-start{background-position:-80px -160px} .ui-icon-seek-first{background-position:-80px -160px}.ui-icon-stop{background-position:-96px -160px}.ui-icon-eject{background-position:-112px -160px}.ui-icon-volume-off{background-position:-128px -160px}.ui-icon-volume-on{background-position:-144px -160px}.ui-icon-power{background-position:0 -176px}.ui-icon-signal-diag{background-position:-16px -176px}.ui-icon-signal{background-position:-32px -176px}.ui-icon-battery-0{background-position:-48px -176px}.ui-icon-battery-1{background-position:-64px -176px}.ui-icon-battery-2{background-position:-80px -176px}.ui-icon-battery-3{background-position:-96px -176px}.ui-icon-circle-plus{background-position:0 -192px}.ui-icon-circle-minus{background-position:-16px -192px}.ui-icon-circle-close{background-position:-32px -192px}.ui-icon-circle-triangle-e{background-position:-48px -192px}.ui-icon-circle-triangle-s{background-position:-64px -192px}.ui-icon-circle-triangle-w{background-position:-80px -192px}.ui-icon-circle-triangle-n{background-position:-96px -192px}.ui-icon-circle-arrow-e{background-position:-112px -192px}.ui-icon-circle-arrow-s{background-position:-128px -192px}.ui-icon-circle-arrow-w{background-position:-144px -192px}.ui-icon-circle-arrow-n{background-position:-160px -192px}.ui-icon-circle-zoomin{background-position:-176px -192px}.ui-icon-circle-zoomout{background-position:-192px -192px}.ui-icon-circle-check{background-position:-208px -192px}.ui-icon-circlesmall-plus{background-position:0 -208px}.ui-icon-circlesmall-minus{background-position:-16px -208px}.ui-icon-circlesmall-close{background-position:-32px -208px}.ui-icon-squaresmall-plus{background-position:-48px -208px}.ui-icon-squaresmall-minus{background-position:-64px -208px}.ui-icon-squaresmall-close{background-position:-80px -208px}.ui-icon-grip-dotted-vertical{background-position:0 -224px}.ui-icon-grip-dotted-horizontal{background-position:-16px -224px}.ui-icon-grip-solid-vertical{background-position:-32px -224px}.ui-icon-grip-solid-horizontal{background-position:-48px -224px}.ui-icon-gripsmall-diagonal-se{background-position:-64px -224px}.ui-icon-grip-diagonal-se{background-position:-80px -224px}  .ui-corner-tl{border-top-left-radius:0}.ui-corner-tr{border-top-right-radius:0}.ui-corner-bl{border-bottom-left-radius:0}.ui-corner-br{border-bottom-right-radius:0}.ui-corner-top{border-top-left-radius:0;border-top-right-radius:0}.ui-corner-bottom{border-bottom-left-radius:0;border-bottom-right-radius:0}.ui-corner-right{border-top-right-radius:0;border-bottom-right-radius:0}.ui-corner-left{border-top-left-radius:0;border-bottom-left-radius:0}.ui-corner-all{border-radius:0} .ui-widget-overlay{background:#000000;opacity:.75;filter:Alpha(Opacity=75)}.ui-widget-shadow{margin:-7px 0 0 -7px;padding:7px;background:#000000 url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAABkAQMAAADOquA5AAAAA1BMVEUAAACnej3aAAAAD0lEQVQoFWNgGAWjgPoAAAJYAAEDeXiTAAAAAElFTkSuQmCC) 50% 50% repeat-x;background:#000000 url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-bg_flat_70_000000_40x100.png?2014-07-29T23:30:00Z) 50% 50% repeat-x!ie;opacity:.20;filter:Alpha(Opacity=20);border-radius:8px}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:bc07054fade6c5c791f4714dfe05b11c */</style><style>
.ui-button{display:inline-block;position:relative;padding:0;margin-right:.1em;text-decoration:none !important;cursor:pointer;text-align:center;zoom:1;overflow:visible; } .ui-button .ui-button-text{display:block;line-height:1.4;text-shadow:0 1px 1px #fff}.ui-button-text-only .ui-button-text{padding:0.3em 1em 0.25em 1em}.ui-button-icon-only .ui-button-text,.ui-button-icons-only .ui-button-text{padding:0.3em;text-indent:-9999999px}.ui-button-text-icon-primary .ui-button-text,.ui-button-text-icons .ui-button-text{padding:0.3em 1em 0.25em 2.1em}.ui-button-text-icon-secondary .ui-button-text,.ui-button-text-icons .ui-button-text{padding:0.3em 2.1em 0.25em 1em}.ui-button-text-icons .ui-button-text{padding-left:2.1em;padding-right:2.1em} input.ui-button{padding:0.3em 1em} .ui-button-icon-only .ui-icon,.ui-button-text-icon-primary .ui-icon,.ui-button-text-icon-secondary .ui-icon,.ui-button-text-icons .ui-icon,.ui-button-text-icon .ui-icon,.ui-button-icons-only .ui-icon{position:absolute;top:50%;margin-top:-9px}.ui-button-icon-only .ui-icon{left:50%;margin-left:-8px}.ui-button-text-icon-primary .ui-button-icon-primary,.ui-button-text-icon .ui-button-icon-primary,.ui-button-text-icons .ui-button-icon-primary,.ui-button-icons-only .ui-button-icon-primary{left:0.5em}.ui-button-text-icon-secondary .ui-button-icon-secondary,.ui-button-text-icon .ui-button-icon-secondary,.ui-button-text-icons .ui-button-icon-secondary,.ui-button-icons-only .ui-button-icon-secondary{right:0.5em} .ui-buttonset{margin-right:7px}.ui-buttonset .ui-button{margin-left:0;margin-right:-.4em} button.ui-button::-moz-focus-inner{border:0;padding:0; } body button.ui-button::-moz-focus-inner{border:0} body .ui-button-large{padding:5px} .ui-button-green .ui-icon,.ui-button-blue .ui-icon,.ui-button-red .ui-icon,.ui-button-orange .ui-icon{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAADwCAMAAADYSUr5AAAA7VBMVEX8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vz8/vywC3+8AAAATnRSTlMAGBAyBAhQv4OZLiJUcEBmYBoSzQwgPBZCSEoeWiYwUiyFNIeBw2rJz8c4RBy9uXyrtaWNqa2zKP2fJO8KBgKPo2KVoa9s351GPm5+kWho0kj9AAAM6klEQVR4XuybAYrjMAxFrRzw3f84C2F2g+ex34Q0NKV6sCzNl2xLVpy47own0DRNUV8ePw/PAHU5xChSUJMx9cYKBGAy0ATBL7VA6kGBOpD/ZAz1vgoEQHPkBHgGrdrdHdhYLrfg8ccQgl5ABe/QuoFSj/cC5QBdAblCPMOxAsIAVAFvwUNUfCIYFCzSC6U14DueAr6FdmOqX4Sapmmapmm+4k2wHvUi5t0OVAiIHZSv/H1A+EKoUBO34gEoATaYzScD5avcHBU3j2riBjz+POIgF1AhXzGfBtj/3Y0r+KDSiMvmDrhSPmUeKuBNFHd+H+A7xGtAPwW+gqZpmqZpGq55A1xqn/cGMIB4weJJONe/E4o+WI8esX0GNpndsZY60ACkrvvP8SBZutQQgbvjl4jEWEFywGLuP26XcQKCzE6OILnHAThAdmYDZnN21P+JFOUShlV+HTHZ3QM418OJ8KzaAHQh60Ng/1zQoUPLvpRVxkV4qH9+TDZN0zRN01z/WSpcHkDcL2aNnRHIasG5AYQOZBUjyAOYj5WoScpQaQONj/chbjCX/ctdAUjLAwCYDxahJi1WEFRMQKm7dZnFDECMH4m6YncOkSlFjFBB3g47wfgKYz0ApKoBjVD+0uVvGTUwQoBKgBK0ToAGIHsZrGWI++dhd98CoYuRboGCOnMLuMbdP2ERwwEIT5kkLYJpjsIiKNCyJP8hqDxHWR6GeA+PRK4Aw86Hvog0TdM0TcO4kyI/mLEHMF7Iujlk/joKfAUqxj9ljdNTRjqvxgGD9NfBTunKFMusswoWSAZMTsxGoIQk8+swZcAh7tKkg/x9Pk6YMYbhly9yvysBBQ6KSd+RGo+vo86wNYowGvPCFJQj8HYXPOPr82Z7aPT2dwKsA7c9Cqjh3RmUlsj8C4RgAMrPKiFYfzHkv2ihzuxecfz6JDFmqN9zHkvTNE3TbIwPxptP7+f8Ea7FT42H4GC9HRjb8jSQbZx826unVsC//daRno1jkvmROKZ/Fw/75Z8csMNzosc5mPSNbTDbHx783APM7vzvOLp4VgL4S0jQUd5KgP53Rc1ygW6Bp1eA7XemBLkC9HuFufyp8SlrgKbXzmyDTWuA7HX/P/spkJb8+QEBhKTOWsHHvQesYbtwDPHR5Pibpmma5k87Z6PctnFF4cPdAIxBCwRFsbalmLVTKXVtN02atAnj1q4Up3Hq5nv/x6kEE7jYHS0kJSyjH3yUhnOwEIhz5vJiYS/pAbwuzUfZKR9pS+TAOFcPHwOgJNyDPos+Hva1SvtXAYUsAR8ffgJMFOlIGPfXyJhgltgpy5yaNhCCQJDElORktvLUVIFf8LEODhifjVnICrKMIkv+X2FDeEKRMGB63is2GyjL0n0gCmQcBGAJiOwMrAKCAECzU9Qm3FQAiQDIsuCAGdnurqcbwHw+F0oCglikA5gEAeJOoaYJZNQEYn7DwPfOSFUAOfYkiaYHNBoRnvEeAHsWwO5i8rsggAcPHgjTNUltG+IAzP/DbgBAEMDIEUVUgxp4cEayAmY5EvmsDUAevCwABzgID2cHzAoePeq+BebKskzzVuPrx5UDMP/39x+mAxhFG8RoNJqNRqiBxWKR7gHMZjnks24AUjcAD3gLgAOAgwPWelcFFNqN7EBPAIoDUBTAJzLJtLoPlKkAQi0xqUENPH78GLJkBfhZns+8BfBBpwN4/AFUMypYFMWSYhQE4GUB/L5+dP1mcQBZFABBBUzNfzoAC/xJTVRyWZaqAD+r8SQ0OZATvCeLor0KFKwpEhVgAVy+B0D4eubfAsCHrxfNA/g4PQ+49GXQzmcKMvBMFPvlsk2vsvyjDXEAlkCpzeF9VeP1i4HJZr84qZ8Jpe4MAwMDAwNPn6oXB05pQAL14/GN+BSATxuZA9177Ck1TKPbs8mF2vgDqEtZqoc92FNIVVUmHN5bAuMMOCxybKIzhek9eldtesD8IywBmJ4BPffzRVFcQUsgtQ5KHDjK1g5TTTFHOoKjyD9QLcw/WALEq8OJtfiMz9hBhleON4MIkobRH/VMf5IZohAqAq1Q72V7pqUKqip1ggBT01OIK045laMNEA/gSQbgakzr+cGLl/sHuVo8ubwuG8Cf+ZzPGXcNAkWkn3R1pqyI576tdtS48wN/2kjrAxqzU1E51dzz1Ph7qQAkkDDNDn/hKV3/eF06AH2hL/XXrNF63FaAaQU6rICKYK5fAhJQnh/4V9R8pYbFIrp3AO9B6g8gqIBPJqeP8/0L4vtxh3PO9Bd8zdf8rdEj2h5g2pu2cfNfnTJJBOAIK0Ln3Tv1dHmyXAugTAXgWRP5j14vCsA0B18+GD/4+zdrPWPN5EJt/mXYW8B0LI+OTFdUjnFfAIpAck5CCcD821UQPu0GIKV6AvBExsVa5j9xA++6/vXi26k0/fZFG8BOhev5exQxJW6iBLuZ/3AekPhn71jDSMbFujL/8WWwxXUdlvcl6X6poILSFLp59E+EEnOg34qBgYGBgRysb5cAj9UD6P9JAVCoB0C/GMdK0gqnlkOwBB6S5999xzd2OuzI0HKf58/ZXybWW+SsySMdb8hTa1ULxnn+KkgAfk0AFYUKKkuPlVbxbHzRav5xxj8bKVY5hao2Ic67O0UNtt2Gg/tXhPeedkccCm62GEsrXrGxAIAK87sC6t+wACyA16+l16/NSC7KCiqlAgiWjCCPF1gA2qH7MRbAT6dgAfBydkr3BVes8mQANKTsxuMF4XtqBYF/d97ce9JIvQHG5l9kNbQ6/HsywHYQzkGuhQWgOgCZ4WK5LIrCdL5ipZzYUSqAhAQpMd1eRf493R7wNZNTeNOZ1wZ/z15/ALvALuw22h0COQvH+efvefly9nLJodbwipU03lwAcQX8C4Cj0L8ZLFY1i1ZHBYNze3t7QQDBe35xysHpD2E+q2QPWC5ns1nQBF/l+Zhi8z3A/K8sATyUToaWAK1/sdrhEEsASbvW9uQJA3jyZP0TBkCyB+R+uVyyJHkZ3PxV4EhHQCtLhaym069MUYrSWQLYk23RRJx/GWTRkOgB5GewRGlgo/OAI0lHONWAVwRA0DFeOTloR4+fj0QQQHfJSubxHp/pqvOA68PuycmujGrHSXJycc+JV05uhoGBgYE8l7H/PcD3+7o7vIW3rfiBNT/orvAI4NFa7ANIAFYDc+Yy9G+gVESpTTEHYL7NAnCuLYEfLYAf+7/7KqSkTNwL2YaUZu4lmWMAtloAUlsCGKRngg5i/1D2L9w0zbvsnenEUtCtdgDn4G2QfhjAlGnsf2zezX9q6W7lKjD9TtI704L5bxhAyZoyEUBb3wY8c50x858IwAUlQyYpw9xGAXjm8zleW8IMpwOIAfMPmP8NVMC2m2AJ4ByNhxML4CSugPQBbHwDPcDkNoib3guTL5JNEM7rfxu7Ckhoa8ypsaI7buSxenqAFIzeqi8Y/OkNwJuf9BuC7gwDAwMDAwMlsdwmjMveT0hsnnv3Yv/EcpuARRAEYPG47g7l2EnlmDC/aaunH3ZK396WUCrUxFKU2hZgEUQBWDztOZdQ2wt3CAKw8TgA06EybZLtBgDTZAAwloC1lMZAtEMQQDAukXSclohbWwGY7pPc2h5g9PeAW3sVoOZ6XAWGecDAwMDAwACV7jDuP+L9gVMLcOjukH/G4n2JWS7KN1Aogvj7D66srykr/ivei1WQypg4AeJnf2V9LXE8k96XemYlAKuFxjgZwoxke9npT7t8m71mPbtpQp2RUevriOewFod4rSkqWDh2EgHMzhjNRqz1iNHobAPNODNOdXecGfX4ta0AqakA6wsrQvuN5JsP4K+srydjKkkVYzWAchZ5GMDtbYIFPDt81m37IFGWhPbRbaV4C7wtdBcZGBgYGLDPB/TrxCKqK2o73lZ0muTnA/p1vIzu6tqOtw19Mfu07F+k44WUV9Xx8bag+4k/H9Bq6OpjgY7X+gRAAJy0mlgrMd4cP3o9xZre8bmkribWgGp9CeLF0TSYlo6PJeCS+4PUr5H6xiUiHT8jdfXPP/9sukZawmUDaJNIaI6l48iQ6NlfsaHe/c3xZc9HQJ9e1v43GEAlVYkAUs9pQ1fXIHGFCliq9g+bewtUVe8J9WvD9EUBAhdUSI9mqSWXCsCamtJNzZrgSbJJEWslxhNNUrEmPd6otIal6V62fRmLj7cF3cu2JzLx8baj+9n+VNaOtxXdz8DAwMDAwAA1bFzfGMjO4AJ9uwOgPwAyuhrUH4DQzQoAyIh1OiAk0afRUAFDD2C4CtxZBgYGBgYGBkbopoBQL3j81f2PdFMYafSrAxiR8H/7K8D8xvpmVgCj5pEIgIbQLwr17e0BviH0P4r9M7oLFWD+Sfi//RWQ9n9XrgIJ/3duHmD+b2QP2BiM7PeaMzDwP8nmcxwZc6CLAAAAAElFTkSuQmCC) !important;background-image:url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/ui-icons_ffffff_256x240.png?2014-07-29T23:30:00Z) !important!ie}  .ui-button.ui-corner-all,.ui-button.ui-corner-top,.ui-button.ui-corner-left,.ui-button.ui-corner-tl{border-top-left-radius:4px}.ui-button.ui-corner-all,.ui-button.ui-corner-top,.ui-button.ui-corner-right,.ui-button.ui-corner-tr{border-top-right-radius:4px}.ui-button.ui-corner-all,.ui-button.ui-corner-bottom,.ui-button.ui-corner-left,.ui-button.ui-corner-bl{border-bottom-left-radius:4px}.ui-button.ui-corner-all,.ui-button.ui-corner-bottom,.ui-button.ui-corner-right,.ui-button.ui-corner-br{border-bottom-right-radius:4px}body .ui-button{color:#2779aa;margin:0.5em 0 0.5em 0.4em;border:1px solid #aaa !important;background:#f0f0f0 !important;background:-moz-linear-gradient(top,#fff 0%,#ddd 90%) !important; background:-webkit-linear-gradient(top,#fff 0%,#ddd 90%) !important; background:-o-linear-gradient(top,#fff 0%,#ddd 90%) !important; background:-ms-linear-gradient(top,#fff 0%,#ddd 90%) !important; background:linear-gradient(to bottom,#fff 0%,#ddd 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffff',endColorstr='#dddddd',GradientType=0); cursor:pointer;font-size:1em;line-height:1.4em;width:auto;overflow:visible;box-shadow:0 1px 3px rgba(0,0,0,.2)}body .ui-button-icon-only{width:2.2em}body .ui-button-icons-only{width:3.4em}body .ui-button:hover{color:#2779aa;border-color:#bbb !important;background:#fff !important;background:-moz-linear-gradient(top,#fff 0%,#eee 90%) !important; background:-webkit-linear-gradient(top,#fff 0%,#eee 90%) !important; background:-o-linear-gradient(top,#fff 0%,#eee 90%) !important; background:-ms-linear-gradient(top,#fff 0%,#eee 90%) !important; background:linear-gradient(to bottom,#fff 0%,#eee 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffff',endColorstr='#eeeeee',GradientType=0); box-shadow:0 1px 3px rgba(0,0,0,.1)}body .ui-button:active,body .ui-button:focus{border-color:#8ad !important;box-shadow:0 0 1px 1px rgba(167,215,249,.5)}body .ui-button:active{background:#e0e0e0 !important;background:-moz-linear-gradient(top,#f0f0f0 0%,#d0d0d0 90%) !important; background:-webkit-linear-gradient(top,#f0f0f0 0%,#d0d0d0 90%) !important; background:-o-linear-gradient(top,#f0f0f0 0%,#d0d0d0 90%) !important; background:-ms-linear-gradient(top,#f0f0f0 0%,#d0d0d0 90%) !important; background:linear-gradient(to bottom,#f0f0f0 0%,#d0d0d0 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#f0f0f0',endColorstr='#d0d0d0',GradientType=0); } body .ui-button-green,body .ui-button-green .ui-button-text{color:white;text-shadow:0 -1px 1px #072}body .ui-button.ui-button-green{border-color:#294 !important;background:#295 !important;background:-moz-linear-gradient(top,#3c8 0%,#295 90%) !important; background:-webkit-linear-gradient(top,#3c8 0%,#295 90%) !important; background:-o-linear-gradient(top,#3c8 0%,#295 90%) !important; background:-ms-linear-gradient(top,#3c8 0%,#295 90%) !important; background:linear-gradient(to bottom,#3c8 0%,#295 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#33cc88',endColorstr='#229955',GradientType=0); box-shadow:0 1px 3px rgba(0,0,0,.3)}body .ui-button.ui-button-green:hover{background:#33a055 !important;background:-moz-linear-gradient(top,#44d388 0%,#33a055 90%) !important; background:-webkit-linear-gradient(top,#44d388 0%,#33a055 90%) !important; background:-o-linear-gradient(top,#44d388 0%,#33a055 90%) !important; background:-ms-linear-gradient(top,#44d388 0%,#33a055 90%) !important; background:linear-gradient(to bottom,#44d388 0%,#33a055 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#44d388',endColorstr='#33a055',GradientType=0); box-shadow:0 1px 3px rgba(0,0,0,.25)}body .ui-button.ui-button-green:active,body .ui-button.ui-button-green:focus{border-color:#172 !important;box-shadow:0 0 2px 2px rgba(167,215,249,.75)}body .ui-button.ui-button-green:active{background:#338855 !important;background:-moz-linear-gradient(top,#30c080 0%,#338855 90%) !important; background:-webkit-linear-gradient(top,#30c080 0%,#338855 90%) !important; background:-o-linear-gradient(top,#30c080 0%,#338855 90%) !important; background:-ms-linear-gradient(top,#30c080 0%,#338855 90%) !important; background:linear-gradient(to bottom,#30c080 0%,#338855 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#30c080',endColorstr='#338855',GradientType=0); } body .ui-button-blue,body .ui-button-blue .ui-button-text{color:white;text-shadow:0 -1px 1px #037}body .ui-button.ui-button-blue{border-color:#468 !important;background:#36b !important;background:-moz-linear-gradient(top,#48e 0%,#36b 90%) !important; background:-webkit-linear-gradient(top,#48e 0%,#36b 90%) !important; background:-o-linear-gradient(top,#48e 0%,#36b 90%) !important; background:-ms-linear-gradient(top,#48e 0%,#36b 90%) !important; background:linear-gradient(to bottom,#48e 0%,#36b 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#4488ee',endColorstr='#3366bb',GradientType=0); box-shadow:0 1px 3px rgba(0,0,0,.35)}body .ui-button.ui-button-blue:hover{background:#36c !important;background:-moz-linear-gradient(top,#59e 0%,#36c 90%) !important; background:-webkit-linear-gradient(top,#59e 0%,#36c 90%) !important; background:-o-linear-gradient(top,#59e 0%,#36c 90%) !important; background:-ms-linear-gradient(top,#59e 0%,#36c 90%) !important; background:linear-gradient(to bottom,#59e 0%,#36c 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#5599ee',endColorstr='#3366cc',GradientType=0); }body .ui-button.ui-button-blue:active,body .ui-button.ui-button-blue:focus{border-color:#357 !important;box-shadow:0 0 2px 2px rgba(167,215,249,.75)}body .ui-button.ui-button-blue:active{background:#3060a0 !important;background:-moz-linear-gradient(top,#4080e0 0%,#3060a0 90%) !important; background:-webkit-linear-gradient(top,#4080e0 0%,#3060a0 90%) !important; background:-o-linear-gradient(top,#4080e0 0%,#3060a0 90%) !important; background:-ms-linear-gradient(top,#4080e0 0%,#3060a0 90%) !important; background:linear-gradient(to bottom,#4080e0 0%,#3060a0 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#4080e0',endColorstr='#3060a0',GradientType=0); } body .ui-button-red,body .ui-button-red .ui-button-text{color:white;text-shadow:0 -1px 1px #700}body .ui-button.ui-button-red{border-color:#944 !important;background:#a22 !important;background:-moz-linear-gradient(top,#d44 0%,#a22 90%) !important; background:-webkit-linear-gradient(top,#d44 0%,#a22 90%) !important; background:-o-linear-gradient(top,#d44 0%,#a22 90%) !important; background:-ms-linear-gradient(top,#d44 0%,#a22 90%) !important; background:linear-gradient(to bottom,#d44 0%,#a22 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#dd4444',endColorstr='#aa2222',GradientType=0); box-shadow:0 1px 3px rgba(0,0,0,.35)}body .ui-button.ui-button-red:hover{border-color:#a44 !important;background:#b03333 !important;background:-moz-linear-gradient(top,#ee4646 0%,#b03333 90%) !important; background:-webkit-linear-gradient(top,#ee4646 0%,#b03333 90%) !important; background:-o-linear-gradient(top,#ee4646 0%,#b03333 90%) !important; background:-ms-linear-gradient(top,#ee4646 0%,#b03333 90%) !important; background:linear-gradient(to bottom,#ee4646 0%,#b03333 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ee4646',endColorstr='#b03333',GradientType=0); box-shadow:0 1px 3px rgba(0,0,0,.3)}body .ui-button.ui-button-red:active,body .ui-button.ui-button-red:focus{border-color:#747 !important;box-shadow:0 0 2px 2px rgba(167,215,249,.7)}body .ui-button.ui-button-red:active{background:#952020 !important;background:-moz-linear-gradient(top,#d04545 0%,#952020 90%) !important; background:-webkit-linear-gradient(top,#d04545 0%,#952020 90%) !important; background:-o-linear-gradient(top,#d04545 0%,#952020 90%) !important; background:-ms-linear-gradient(top,#d04545 0%,#952020 90%) !important; background:linear-gradient(to bottom,#d04545 0%,#952020 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#d04545',endColorstr='#952020',GradientType=0); } body .ui-button-green.disabled,body .ui-button-green.disabled:hover,body .ui-button-green.disabled:active,body .ui-button-green.disabled:focus,body .ui-button-blue.disabled,body .ui-button-blue.disabled:hover,body .ui-button-blue.disabled:active,body .ui-button-blue.disabled:focus,body .ui-button-red.disabled,body .ui-button-red.disabled:hover,body .ui-button-red.disabled:active,body .ui-button-red.disabled:focus,body .ui-button.disabled,body .ui-button.disabled:hover{color:#aaa;border-color:#ccc !important;background:#eee !important;background:-moz-linear-gradient(top,#f6f6f6 0%,#eee 90%) !important; background:-webkit-linear-gradient(top,#f6f6f6 0%,#eee 90%) !important; background:-o-linear-gradient(top,#f6f6f6 0%,#eee 90%) !important; background:-ms-linear-gradient(top,#f6f6f6 0%,#eee 90%) !important; background:linear-gradient(to bottom,#f6f6f6 0%,#eee 90%) !important;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#f6f6f6',endColorstr='#eeeeee',GradientType=0); box-shadow:0 1px 3px rgba(0,0,0,0)}body .ui-button-green.disabled .ui-button-text,body .ui-button-blue.disabled .ui-button-text,body .ui-button-red.disabled .ui-button-text{color:#aaa;text-shadow:0 1px 1px #fff}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:19b56fa5ee3225e01c82480e244ecedf */
.ui-resizable{position:relative}.ui-resizable-handle{position:absolute;font-size:0.1px;z-index:99999;display:block}.ui-resizable-disabled .ui-resizable-handle,.ui-resizable-autohide .ui-resizable-handle{display:none}.ui-resizable-n{cursor:n-resize;height:7px;width:100%;top:-5px;left:0}.ui-resizable-s{cursor:s-resize;height:7px;width:100%;bottom:-5px;left:0} .ui-resizable-e{cursor:e-resize;width:7px;right:-5px;top:0;height:100%} .ui-resizable-w{cursor:w-resize;width:7px;left:-5px;top:0;height:100%} .ui-resizable-se{cursor:se-resize;width:12px;height:12px;right:1px;bottom:1px} .ui-resizable-sw{cursor:sw-resize;width:9px;height:9px;left:-5px;bottom:-5px} .ui-resizable-nw{cursor:nw-resize;width:9px;height:9px;left:-5px;top:-5px} .ui-resizable-ne{cursor:ne-resize;width:9px;height:9px;right:-5px;top:-5px}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:6edb0b5932c338be8f0957237aa57681 */
.ui-dialog{position:absolute;padding:0;width:300px}.ui-dialog .ui-dialog-titlebar{padding:.75em;position:relative}.ui-dialog .ui-dialog-title{float:left;margin:0}.ui-dialog .ui-dialog-titlebar-close{position:absolute;right:.75em;top:50%;width:19px;margin:-10px 0 0 0;padding:1px;height:18px}.ui-dialog .ui-dialog-titlebar-close span{display:block;margin:1px}.ui-dialog .ui-dialog-titlebar-close:hover,.ui-dialog .ui-dialog-titlebar-close:focus{padding:0}.ui-dialog .ui-dialog-content{border:0;padding:.5em 1em;background:none;overflow:auto;zoom:1}.ui-dialog .ui-dialog-buttonpane{text-align:left;border-width:1px 0 0 0;background-image:none;margin:.5em 0 0 0;padding:.3em 1em .5em .4em}.ui-dialog .ui-dialog-buttonpane .ui-dialog-buttonset{float:right}.ui-dialog .ui-resizable-se{width:14px;height:14px;right:3px;bottom:3px}.ui-draggable .ui-dialog-titlebar{cursor:move} body .ui-dialog .ui-dialog-titlebar-close:hover{text-decoration:none}body .ui-dialog .ui-dialog-content .status-invalid input{border:2px solid red;padding:2px 1px}body .ui-dialog .ui-dialog-titlebar{padding:0.9em 1.4em 0.6em !important}body .ui-dialog .ui-widget-header{background:#f0f0f0 url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAkCAAAAABtHw/QAAAAGElEQVQIW2P4wMTA9B8Fo5IIGl0EQQIxAEzaGCA3rKnhAAAAAElFTkSuQmCC) repeat-x scroll 50% 100% !important;background:#f0f0f0 url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/titlebar-fade.png?2014-07-24T17:18:20Z) repeat-x scroll 50% 100% !important!ie} body .ui-dialog .ui-icon-closethick{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIBAMAAAA2IaO4AAAAElBMVEUAAAAAAAD///8AAAAAAAAAAAAtTix5AAAABXRSTlMNTQC/s2KwEqEAAAAjSURBVAgdYwhhUnBlEDVgDmRgDDYVYFAQDWSCEGAuWAKkBABiBwTrflTh/wAAAABJRU5ErkJggg==) no-repeat 50% 50% !important;background:url(//bits.wikimedia.org/static-1.24wmf15/resources/src/jquery.ui-themes/vector/images/close.png?2014-07-24T17:18:20Z) no-repeat 50% 50% !important!ie}body .ui-dialog .ui-dialog-buttonpane{margin-top:0 !important;padding:0.3em 1.4em 0.5em 1.4em !important}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:cd09b7343e5829ab5e36063263714a6b */
#noteTA-dialog a{color:#3366BB}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:9f180117972d9428d2068858fd3ce297 */</style><meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/load.css">
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: zhwiki:resourceloader:filter:minify-css:7:a13f9f0382ae47ff093d83d6284c8a1c */</style>
<script src="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/load_003.php"></script><script src="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/load_004.php"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"C++11","wgTitle":"C++11","wgCurRevisionId":32096808,"wgRevisionId":32096808,"wgArticleId":972235,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["自2009年4月有未列明来源语句的条目","C++","程式語言標準"],"wgBreakFrames":false,"wgPageContentLanguage":"zh","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"zh","wgMonthNames":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgMonthNamesShort":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgRelevantPageName":"C++11","wgUserVariant":"zh-cn","wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":false,"previewDialog":false,"publish":false},"wgBetaFeaturesFeatures":[],"wgMediaViewerOnClick":true,"wgVisualEditor":{"isPageWatched":false,"magnifyClipIconURL":"//bits.wikimedia.org/static-1.24wmf15/skins/common/images/magnify-clip.png","pageLanguageCode":"zh","pageLanguageDir":"ltr","svgMaxSize":2048,"namespacesWithSubpages":{"1":true,"2":true,"3":true,"4":true,"5":true,"7":true,"8":true,"9":true,"10":true,"11":true,"12":true,"13":true,"15":true,"100":true,"101":true,"102":true,"103":true,"104":true,"105":true,"106":true,"107":true,"108":true,"109":true,"110":true,"111":true,"828":true,"829":true}},"wikilove-recipient":"","wikilove-anon":0,"wgGuidedTourHelpGuiderUrl":"Help:导览/向导","wgULSAcceptLanguageList":["zh-cn","zh-tw","zh-hk","zh-sg","zh","en-us","en"],"wgULSCurrentAutonym":"中文（中国大陆）‎","wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","wgNoticeProject":"wikipedia","wgWikibaseItemId":"Q1061570"});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":0,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":false,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":4,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"multimediaviewer-enable":true,"visualeditor-enable":0,"visualeditor-betatempdisable":0,"visualeditor-enable-experimental":0,"visualeditor-enable-language":0,"visualeditor-hidebetawelcome":0,"wikilove-enabled":1,"mathJax":false,"echo-notify-show-link":true,"echo-show-alert":true,"echo-email-frequency":0,"echo-email-format":"html","echo-subscriptions-email-system":true,"echo-subscriptions-web-system":true,"echo-subscriptions-email-user-rights":true,"echo-subscriptions-web-user-rights":true,"echo-subscriptions-email-other":false,"echo-subscriptions-web-other":true,"echo-subscriptions-email-edit-user-talk":false,"echo-subscriptions-web-edit-user-talk":true,"echo-subscriptions-email-reverted":false,"echo-subscriptions-web-reverted":true,"echo-subscriptions-email-article-linked":false,"echo-subscriptions-web-article-linked":false,"echo-subscriptions-email-mention":false,"echo-subscriptions-web-mention":true,
"echo-subscriptions-web-edit-thank":true,"echo-subscriptions-email-edit-thank":false,"gettingstarted-task-toolbar-show-intro":true,"uls-preferences":"","language":"zh-cn","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant":"zh-cn","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs100":false,"searchNs101":false,"searchNs828":false,"searchNs829":false,"gadget-edit0":1,"gadget-WikiMiniAtlas":1,"gadget-ReferenceTooltips":1,"gadget-UnihanTooltips":1,"gadget-variant-link-fix":1,"gadget-FixedTopBottomLink":1,"gadget-AdvancedSiteNotices":1,"gadget-hideConversionTab":1,"gadget-large-font":1,"gadget-internalLinkHelper-altcolor":1,
"gadget-noteTA":1,"gadget-noteTAvector":1,"gadget-NavFrame":1,"gadget-collapsibleTables":1,"gadget-CleanDeleteReasons":1});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: zhwiki:resourceloader:filter:minify-js:7:8ff0df7662f3036b016b542150f1bb4e */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","ext.gadget.variant-link-fix","ext.centralauth.centralautologin","mmv.head","ext.visualEditor.viewPageTarget.init","ext.uls.init","ext.uls.interface","ext.centralNotice.bannerController","skins.vector.js"]);
}</script><script src="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/load_002.php"></script>
<link rel="dns-prefetch" href="http://meta.wikimedia.org/">
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/w/static-1.24wmf15/skins/Vector/csshover.min.htc")}</style><![endif]-->
<script type="text/javascript" src="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/index_002.php"></script><style type="text/css"> #fi #fic {margin-right:100px !important}  #fi #rh {margin-left:-115px !important;width:95px !important}  #fi .rh {display:none !important}  body:not(.xE) div[role='main'] .Bu:not(:first-child) {display: none !important} </style><link href="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/sbi.css" rel="stylesheet" type="text/css" id="sbi-style"></head>
<body ryt12142="1" class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-C_11 skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

							<div id="siteNotice"><div id="centralNotice"></div><!-- CentralNotice --></div>
						<h1 id="firstHeading" class="firstHeading" lang="zh-CN"><div style="float: right;"></div><span dir="auto">C++11</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=0" title="编辑首段">编辑</a><span class="mw-editsection-bracket">]</span></span></h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">维基百科，自由的百科全书</div>
								<div id="contentSub" dir="ltr" lang="zh-CN"></div>
												<div id="jump-to-nav" class="mw-jump">
					跳转至：					<a href="#mw-navigation">导航</a>、					<a href="#p-search">搜索</a>
				</div>
				<div id="mw-content-text" dir="ltr" class="mw-content-ltr" lang="zh-CN">
<div id="noteTA-45218" class="noteTA">
<div class="noteTA-group">
<div data-noteta-group-source="module" data-noteta-group="IT"></div>
</div>
<div class="noteTA-local">
<div data-noteta-code="zh-hans:数组;zh-hant:陣列;"></div>
<div data-noteta-code="zh-hans:构造函数;zh-hant:建構子;"></div>
<div data-noteta-code="zh-hans:构造函数;zh-hant:建構式;"></div>
<div data-noteta-code="zh-hans:构造函数;zh-hant:构造式;"></div>
<div data-noteta-code="zh-hans:构造;zh-hant:建構;"></div>
<div data-noteta-code="zh-hans:指针;zh-hant:指標;"></div>
<div data-noteta-code="zh-hans:临时;zh-hant:暫時;"></div>
<div data-noteta-code="zh-hans:对象;zh-hant:物件;"></div>
<div data-noteta-code="zh-hans:析构函数;zh-hant:解構式;"></div>
<div data-noteta-code="zh-hans:析构;zh-hant:解構;"></div>
<div data-noteta-code="zh-hans:内存;zh-hant:記憶體;"></div>
<div data-noteta-code="zh-hans:函数;zh-hant:函式;"></div>
<div data-noteta-code="zh-hans:调用;zh-hant:呼叫;"></div>
<div data-noteta-code="zh-hans:调用;zh-hant:喚起;"></div>
<div data-noteta-code="zh-hans:参数;zh-hant:變數;"></div>
<div data-noteta-code="zh-hans:声明;zh-hant:宣告;"></div>
<div data-noteta-code="zh-hans:引用;zh-hant:引數;"></div>
<div data-noteta-code="zh-hans:引用;zh-hant:參考;"></div>
<div data-noteta-code="zh-hans:列表;zh-hant:串列;"></div>
<div data-noteta-code="zh-hans:回返;zh-hant:返回;"></div>
<div data-noteta-code="zh-hans:实现;zh-hant:實做;"></div>
<div data-noteta-code="zh-hans:派生;zh-hant:衍伸;"></div>
<div data-noteta-code="zh-hans:布尔;zh-hant:布林;"></div>
<div data-noteta-code="zh-hans:转义;zh-hant:跳脫;"></div>
<div data-noteta-code="zh-hans:线程;zh-hant:緒程;"></div>
<div data-noteta-code="zh-hans:预处理器;zh-hant:前處理器;"></div>
<div data-noteta-code="zh-hans:模式;zh-hant:樣式;"></div>
<div data-noteta-code="zh-hans:实体;zh-hant:實體;"></div>
</div>
</div>
<p><b>C++11</b>，先前被称作<b>C++0x</b>，即ISO/IEC 14882:2011，是目前的<a href="http://zh.wikipedia.org/wiki/C%2B%2B%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80" title="C++编程语言" class="mw-redirect">C++编程语言</a>的正式标准。它取代第二版标准ISO/IEC 14882:2003(第一版ISO/IEC 14882:1998公开于1998年，第二版于2003年更新，分别通称C++98以及C++03，两者差异很小)。新的标准包含<a href="http://zh.wikipedia.org/wiki/%E6%A0%B8%E5%BF%83%E8%AA%9E%E8%A8%80" title="核心语言">核心语言</a>的新机能，而且扩展<a href="http://zh.wikipedia.org/wiki/C%2B%2B%E6%A8%99%E6%BA%96%E7%A8%8B%E5%BC%8F%E5%BA%AB" title="C++标准程序库">C++标准程序库</a>，并入了大部分的<a href="http://zh.wikipedia.org/wiki/C%2B%2B_Technical_Report_1" title="C++ Technical Report 1">C++ Technical Report 1</a>程序库(数学的特殊函数除外)。最新的消息被公开在<a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/">ISO C++ 委员会网站(英文)</a>。</p>
<p><a href="http://zh.wikipedia.org/wiki/ISO" title="ISO" class="mw-redirect">ISO</a>／<a href="http://zh.wikipedia.org/wiki/IEC" title="IEC" class="mw-redirect">IEC</a>
 JTC1/SC22/WG21 C++ 
标准委员会计划在2010年8月之前完成对最终委员会草案的投票，以及于2011年3月召开的标准会议完成国际标准的最终草案。然而，WG21预期ISO
将要花费六个月到一年的时间才能正式发布新的 C++ 标准。为了能够如期完成，委员会决定致力于直至2006年为止的提案，忽略新的提案<sup class="reference" id="ref_strousup-brieflooka"><a href="#endnote_strousup-brieflooka">[1]</a></sup>。最终于2011年8月12日公布，并于2011年9月出版。</p>
<p>2012年2月28日的国际标准草案(<a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf">N3376</a>)是最接近于现行标准的草案，差异仅有编辑上的修正。</p>
<p>像C++这样的<a href="http://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80" title="编程语言" class="mw-redirect">编程语言</a>，通过一种演化的的过程来发展其定义。这个过程不可避免地将引发与现有代码的兼容问题，在C++的发展过程中偶尔会发生。不过根据<a href="http://zh.wikipedia.org/wiki/Bjarne_Stroustrup" title="Bjarne Stroustrup" class="mw-redirect">Bjarne Stroustrup</a>(C++的创始人并且是委员会的一员)表示，新的标准将几乎100%兼容于现有标准。</p>
<p></p>
<div id="toc" class="toc">
<div id="toctitle">
<h2>目录</h2>
<span class="toctoggle">&nbsp;[<a href="#" class="internal" id="togglelink">隐藏</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.E5.80.99.E9.81.B8.E8.AE.8A.E6.9B.B4"><span class="tocnumber">1</span> <span class="toctext">候选变更</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#C.2B.2B.E6.A0.B8.E5.BF.83.E8.AA.9E.E8.A8.80.E7.9A.84.E6.93.B4.E5.85.85"><span class="tocnumber">2</span> <span class="toctext">C++核心语言的扩充</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#.E6.A0.B8.E5.BF.83.E8.AA.9E.E8.A8.80.E7.9A.84.E5.9F.B7.E8.A1.8C.E6.9C.9F.E8.A1.A8.E7.8F.BE.E5.BC.B7.E5.8C.96"><span class="tocnumber">3</span> <span class="toctext">核心语言的运行期表现强化</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#.E5.8F.B3.E5.80.BC.E5.BC.95.E7.94.A8.E5.92.8C_move_.E8.AA.9E.E6.84.8F"><span class="tocnumber">3.1</span> <span class="toctext">右值引用和 move 语义</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#.E6.B3.9B.E5.8C.96.E7.9A.84.E5.B8.B8.E6.95.B8.E8.A1.A8.E7.A4.BA.E5.BC.8F"><span class="tocnumber">3.2</span> <span class="toctext">泛化的常数表示式</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#.E5.B0.8DPOD.E5.AE.9A.E7.BE.A9.E7.9A.84.E4.BF.AE.E6.AD.A3"><span class="tocnumber">3.3</span> <span class="toctext">对POD定义的修正</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#.E6.A0.B8.E5.BF.83.E8.AA.9E.E8.A8.80.E5.BB.BA.E6.A7.8B.E6.9C.9F.E8.A1.A8.E7.8F.BE.E7.9A.84.E5.8A.A0.E5.BC.B7"><span class="tocnumber">4</span> <span class="toctext">核心语言构造期表现的加强</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#.E5.A4.96.E9.83.A8.E6.A8.A1.E6.9D.BF"><span class="tocnumber">4.1</span> <span class="toctext">外部模板</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#.E6.A0.B8.E5.BF.83.E8.AA.9E.E8.A8.80.E4.BD.BF.E7.94.A8.E6.80.A7.E7.9A.84.E5.8A.A0.E5.BC.B7"><span class="tocnumber">5</span> <span class="toctext">核心语言使用性的加强</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="#.E5.88.9D.E5.A7.8B.E5.8C.96.E5.88.97.E8.A1.A8"><span class="tocnumber">5.1</span> <span class="toctext">初始化列表</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#.E7.B5.B1.E4.B8.80.E7.9A.84.E5.88.9D.E5.A7.8B.E5.8C.96"><span class="tocnumber">5.2</span> <span class="toctext">统一的初始化</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#.E5.9E.8B.E5.88.A5.E6.8E.A8.E5.B0.8E"><span class="tocnumber">5.3</span> <span class="toctext">类型推导</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#.E4.BB.A5.E7.AF.84.E5.9C.8D.E7.82.BA.E5.9F.BA.E7.A4.8E.E7.9A.84_for_.E8.BF.B4.E5.9C.88"><span class="tocnumber">5.4</span> <span class="toctext">以范围为基础的 for 循环</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Lambda.E5.87.BD.E5.BC.8F.E8.88.87.E8.A1.A8.E7.A4.BA.E5.BC.8F"><span class="tocnumber">5.5</span> <span class="toctext">Lambda函数与表示式</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#.E8.BF.94.E5.9B.9E.E5.9E.8B.E5.88.A5.E5.BE.8C.E7.BD.AE.E7.9A.84.E5.87.BD.E5.BC.8F.E5.AE.A3.E5.91.8A"><span class="tocnumber">5.6</span> <span class="toctext">回返类型后置的函数声明</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#.E7.89.A9.E4.BB.B6.E5.BB.BA.E6.A7.8B.E7.9A.84.E6.94.B9.E8.89.AF"><span class="tocnumber">5.7</span> <span class="toctext">对象构造的改良</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#.E9.A1.AF.E5.BC.8F.E8.99.9B.E5.87.BD.E6.95.B8.E9.87.8D.E8.BC.89"><span class="tocnumber">5.8</span> <span class="toctext">显式虚函数重载</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#.E7.A9.BA.E6.8C.87.E6.A8.99"><span class="tocnumber">5.9</span> <span class="toctext">空指针</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#.E5.BC.B7.E5.9E.8B.E5.88.A5.E5.88.97.E8.88.89"><span class="tocnumber">5.10</span> <span class="toctext">强类型枚举</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#.E8.A7.92.E6.8B.AC.E8.99.9F"><span class="tocnumber">5.11</span> <span class="toctext">角括号</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#.E9.A1.AF.E5.BC.8F.E5.9E.8B.E5.88.A5.E8.BD.89.E6.8F.9B.E5.AD.90"><span class="tocnumber">5.12</span> <span class="toctext">显式类型转换子</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#.E6.A8.A1.E6.9D.BF.E7.9A.84.E5.88.A5.E5.90.8D"><span class="tocnumber">5.13</span> <span class="toctext">模板的别名</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#.E7.84.A1.E9.99.90.E5.88.B6.E7.9A.84unions"><span class="tocnumber">5.14</span> <span class="toctext">无限制的unions</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-24"><a href="#.E6.A0.B8.E5.BF.83.E8.AA.9E.E8.A8.80.E8.83.BD.E5.8A.9B.E7.9A.84.E6.8F.90.E5.8D.87"><span class="tocnumber">6</span> <span class="toctext">核心语言能力的提升</span></a>
<ul>
<li class="toclevel-2 tocsection-25"><a href="#-.7BA.7Czh-hans:.E5.8F.98.E9.95.BF.E5.8F.82.E6.95.B0.E6.A8.A1.E6.9D.BF.3B_zh-hant:.E4.B8.8D.E5.AE.9A.E9.95.B7.E5.8F.83.E6.95.B8.E6.A8.A1.E6.9D.BF.7D-"><span class="tocnumber">6.1</span> <span class="toctext">变长参数模板</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#.E6.96.B0.E7.9A.84.E5.AD.97.E4.B8.B2.E5.AD.97.E9.9D.A2.E5.80.BC"><span class="tocnumber">6.2</span> <span class="toctext">新的字符串字面值</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="#.E4.BD.BF.E7.94.A8.E8.80.85.E8.87.AA.E8.A8.82.E7.9A.84.E5.AD.97.E9.9D.A2.E5.80.BC"><span class="tocnumber">6.3</span> <span class="toctext">用户自定义的字面值</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="#.E5.A4.9A.E5.B7.A5.E8.A8.98.E6.86.B6.E9.AB.94.E6.A8.A1.E5.9E.8B"><span class="tocnumber">6.4</span> <span class="toctext">多任务内存模型</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="#thread-local.E7.9A.84.E5.AD.98.E5.84.B2.E6.9C.9F.E9.99.90"><span class="tocnumber">6.5</span> <span class="toctext">thread-local的存储期限</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#.E4.BD.BF.E7.94.A8.E6.88.96.E7.A6.81.E7.94.A8.E7.89.A9.E4.BB.B6.E7.9A.84.E9.A0.90.E8.A8.AD.E5.87.BD.E5.BC.8F"><span class="tocnumber">6.6</span> <span class="toctext">使用或禁用对象的默认函数</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#long_long_int.E5.9E.8B.E5.88.A5"><span class="tocnumber">6.7</span> <span class="toctext">long long int类型</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#.E9.9D.9C.E6.85.8Bassertion"><span class="tocnumber">6.8</span> <span class="toctext">静态assertion</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#.E5.85.81.E8.A8.B1sizeof.E9.81.8B.E7.AE.97.E5.AD.90.E4.BD.9C.E7.94.A8.E5.9C.A8.E9.A1.9E.E5.88.A5.E7.9A.84.E8.B3.87.E6.96.99.E6.88.90.E5.93.A1.E4.B8.8A.EF.BC.8C.E7.84.A1.E9.A0.88.E6.98.8E.E7.A2.BA.E7.9A.84.E7.89.A9.E4.BB.B6"><span class="tocnumber">6.9</span> <span class="toctext">允许sizeof运算符作用在类型的数据成员上，无须明确的对象</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#.E5.9E.83.E5.9C.BE.E5.9B.9E.E6.94.B6.E6.A9.9F.E5.88.B6"><span class="tocnumber">6.10</span> <span class="toctext">垃圾回收机制</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-35"><a href="#C.2B.2B.E6.A8.99.E6.BA.96.E7.A8.8B.E5.BC.8F.E5.BA.AB.E7.9A.84.E8.AE.8A.E6.9B.B4"><span class="tocnumber">7</span> <span class="toctext">C++标准程序库的变更</span></a>
<ul>
<li class="toclevel-2 tocsection-36"><a href="#.E6.A8.99.E6.BA.96.E5.BA.AB.E5.85.83.E4.BB.B6.E4.B8.8A.E7.9A.84.E5.8D.87.E7.B4.9A"><span class="tocnumber">7.1</span> <span class="toctext">标准库组件上的升级</span></a></li>
<li class="toclevel-2 tocsection-37"><a href="#.E5.9F.B7.E8.A1.8C.E7.B7.92.E6.94.AF.E6.8F.B4"><span class="tocnumber">7.2</span> <span class="toctext">线程支持</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="#.E5.A4.9A.E5.85.83.E7.B5.84.E5.9E.8B.E5.88.A5"><span class="tocnumber">7.3</span> <span class="toctext">多元组类型</span></a></li>
<li class="toclevel-2 tocsection-39"><a href="#.E9.9B.9C.E6.B9.8A.E8.A1.A8"><span class="tocnumber">7.4</span> <span class="toctext">散列表</span></a></li>
<li class="toclevel-2 tocsection-40"><a href="#.E6.AD.A3.E8.A6.8F.E8.A1.A8.E7.A4.BA.E5.BC.8F"><span class="tocnumber">7.5</span> <span class="toctext">正则表达式</span></a></li>
<li class="toclevel-2 tocsection-41"><a href="#.E9.80.9A.E7.94.A8.E6.99.BA.E8.83.BD.E6.8C.87.E9.87.9D"><span class="tocnumber">7.6</span> <span class="toctext">通用智能指针</span></a></li>
<li class="toclevel-2 tocsection-42"><a href="#.E5.8F.AF.E6.89.A9.E5.B1.95.E7.9A.84.E9.9A.8F.E6.9C.BA.E6.95.B0.E5.8A.9F.E8.83.BD"><span class="tocnumber">7.7</span> <span class="toctext">可扩展的随机数功能</span></a></li>
<li class="toclevel-2 tocsection-43"><a href="#.E5.8C.85.E8.A3.85.E5.BC.95.E7.94.A8"><span class="tocnumber">7.8</span> <span class="toctext">包装引用</span></a></li>
<li class="toclevel-2 tocsection-44"><a href="#.E5.A4.9A.E6.80.81.E5.87.BD.E6.95.B0.E5.AF.B9.E8.B1.A1.E5.8C.85.E8.A3.85.E5.99.A8"><span class="tocnumber">7.9</span> <span class="toctext">多态函数对象包装器</span></a></li>
<li class="toclevel-2 tocsection-45"><a href="#.E7.94.A8.E6.96.BC.E5.85.83.E7.B7.A8.E7.A8.8B.E7.9A.84.E5.9E.8B.E5.88.A5.E5.B1.AC.E6.80.A7"><span class="tocnumber">7.10</span> <span class="toctext">用于元编程的类型属性</span></a></li>
<li class="toclevel-2 tocsection-46"><a href="#.E7.94.A8.E4.BA.8E.E8.AE.A1.E7.AE.97.E5.87.BD.E6.95.B0.E5.AF.B9.E8.B1.A1.E8.BF.94.E5.9B.9E.E7.B1.BB.E5.9E.8B.E7.9A.84.E7.BB.9F.E4.B8.80.E6.96.B9.E6.B3.95"><span class="tocnumber">7.11</span> <span class="toctext">用于计算函数对象回返类型的统一方法</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-47"><a href="#.E5.B7.B2.E8.A2.AB.E7.A7.BB.E9.99.A4.E6.88.96.E6.98.AF.E4.B8.8D.E5.8C.85.E5.90.AB.E5.9C.A8_C.2B.2B11_.E6.A8.99.E6.BA.96.E7.9A.84.E7.89.B9.E8.89.B2"><span class="tocnumber">8</span> <span class="toctext">已被卸载或是不包含在 C++11 标准的特色</span></a></li>
<li class="toclevel-1 tocsection-48"><a href="#.E8.A2.AB.E7.A7.BB.E9.99.A4.E6.88.96.E5.BB.A2.E6.A3.84.E7.9A.84.E7.89.B9.E8.89.B2"><span class="tocnumber">9</span> <span class="toctext">被卸载或废弃的特色</span></a></li>
<li class="toclevel-1 tocsection-49"><a href="#.E7.BC.96.E8.AF.91.E5.99.A8.E5.AE.9E.E7.8E.B0"><span class="tocnumber">10</span> <span class="toctext">编译器实现</span></a></li>
<li class="toclevel-1 tocsection-50"><a href="#.E9.97.9C.E8.81.AF.E9.A0.85.E7.9B.AE"><span class="tocnumber">11</span> <span class="toctext">关系项目</span></a></li>
<li class="toclevel-1 tocsection-51"><a href="#.E5.8F.83.E8.80.83.E8.B3.87.E6.96.99"><span class="tocnumber">12</span> <span class="toctext">参考资料</span></a>
<ul>
<li class="toclevel-2 tocsection-52"><a href="#C.2B.2B.E6.A8.99.E6.BA.96.E5.A7.94.E5.93.A1.E6.9C.83.E6.96.87.E4.BB.B6"><span class="tocnumber">12.1</span> <span class="toctext">C++标准委员会文件</span></a></li>
<li class="toclevel-2 tocsection-53"><a href="#.E6.96.87.E7.AB.A0"><span class="tocnumber">12.2</span> <span class="toctext">文章</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-54"><a href="#.E5.A4.96.E9.83.A8.E9.80.A3.E7.B5.90"><span class="tocnumber">13</span> <span class="toctext">外部链接</span></a></li>
</ul>
</div>
<p></p>
<h2><span class="mw-headline" id=".E5.80.99.E9.81.B8.E8.AE.8A.E6.9B.B4">候选变更</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=1" title="编辑段落：候选变更">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>C++的修订包含核心语言以及标准程序库。</p>
<p>在发展新标准的每个机能上，委员会采取了几个方向：</p>
<ul>
<li>维持与C++98，可能的话还有<a href="http://zh.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80" title="C语言" class="mw-redirect">C</a>之间的稳定性与兼容性；</li>
<li>尽可能不通过核心语言的扩展，而是通过标准程序库来引进新的特色；</li>
<li>能够演进编程技术的变更优先；</li>
<li>改进 C++ 以帮助系统以及库设计，而不是引进只针对特别应用的新特色；</li>
<li>增进类型安全，提供对现行不安全的技术更安全的替代方案；</li>
<li>增进直接对硬件工作的能力与表现；</li>
<li>提供现实世界中问题的适当解决方案；</li>
<li>实行“zero-overhead”原则(某些功能要求的额外支持只有在该功能被使用时才能使用);</li>
<li>使C++易于教授与学习</li>
</ul>
<p>对初学者的注重被认为是重要的，因为他们构成了计算机程序员的主体。也因为许多初学者不愿扩展他们对 C++ 的知识，只限于使用他们对 C++ 
专精的部分。此外，考虑到 C++ 被广泛的使用(包含应用领域和编程风格)，即便是最有经验的程序员在面对新的编程范式时也会成为初学者。</p>
<h2><span class="mw-headline" id="C.2B.2B.E6.A0.B8.E5.BF.83.E8.AA.9E.E8.A8.80.E7.9A.84.E6.93.B4.E5.85.85">C++核心语言的扩充</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=2" title="编辑段落：C++核心语言的扩充">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>C++委员会的主要焦点是在语言核心的发展上。核心语言将被大幅改善的领域包括<a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9F%B7%E8%A1%8C%E7%B7%92_%28%E9%9B%BB%E8%85%A6%E7%A1%AC%E9%AB%94%29" title="多线程 (电脑硬件)" class="mw-redirect">多线程</a>(或称为“多线程”)支持、<a href="http://zh.wikipedia.org/wiki/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B" title="泛型编程" class="mw-redirect">泛型编程</a>、统一的初始化，以及性能表现的加强。</p>
<p>在此分成4个区块来讨论核心语言的特色以及变更： 运行期表现强化、构造期表现强化、可用性强化，还有新的功能。某些特色可能会同时属于多个区块，但在此仅于其最具代表性的区块描述该特色。</p>
<h2><span class="mw-headline" id=".E6.A0.B8.E5.BF.83.E8.AA.9E.E8.A8.80.E7.9A.84.E5.9F.B7.E8.A1.8C.E6.9C.9F.E8.A1.A8.E7.8F.BE.E5.BC.B7.E5.8C.96">核心语言的运行期表现强化</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=3" title="编辑段落：核心语言的运行期表现强化">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>以下的语言机能主要用来提升某些性能表现，像是内存或是速度上的表现。</p>
<h3><span class="mw-headline" id=".E5.8F.B3.E5.80.BC.E5.BC.95.E7.94.A8.E5.92.8C_move_.E8.AA.9E.E6.84.8F">右值引用和 move 语义</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=4" title="编辑段落：右值引用和 move 语义">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在 C++03及之前的标准，临时对象(称为右值"R-values"，位于赋值运算符之右)无法被改变，在 C 中亦同(且被视为无法和 <b>const T&amp;</b> 做出区分)。尽管在某些情况下临时对象的确会被改变，甚至也被视为是一个有用的漏洞。</p>
<p>C++11 增加一个新的非常数引用(reference)类型，称作右值引用(R-value reference)，标记为<tt>T &amp;&amp;</tt>。右值引用所引用的临时对象可以在该临时对象被初始化之后做修改，这是为了允许 move 语义。</p>
<p>C++03 性能上被长期被诟病的其中之一，就是其耗时且不必要的深度拷贝。深度拷贝会发生在当对象是以传值的方式传递。举例而言，<tt>std::vector&lt;T&gt;</tt> 是内部保存了 C-style 数组的一个包装，如果一个<tt>std::vector&lt;T&gt;</tt>的临时对象被构造或是从函数回返，要将其存储只能通过生成新的<tt>std::vector&lt;T&gt;</tt>并且把该临时对象所有的数据复制进去。该临时对象和其拥有的内存会被摧毁。(为了讨论上的方便，这里忽略回返值优化)</p>
<p>在 C++11，一个<tt>std::vector</tt>的 "move 构造函数" 对某个<tt>vector</tt>的右值引用可以单纯地从右值复制其内部 C-style 数组的指针到新的 vector，然后留下空的右值。这个操作不需要数组的复制，而且空的临时对象的析构也不会摧毁内存。传回<tt>vector</tt>临时对象的函数不需要显式地传回<tt>std::vector&lt;T&gt;&amp;&amp;</tt>。如果<tt>vector</tt>没有 move 构造函数，那么复制构造函数将被调用，以<tt>const std::vector&lt;T&gt; &amp;</tt>的正常形式。 如果它确实有 move 构造函数，那么就会调用 move 构造函数，这能够免除大幅的内存配置。</p>
<p>基于安全的理由，具名的参数将永远不被认定为右值，即使它是被如此声明的；为了获得右值必须使用 <tt>std::move&lt;T&gt;()</tt>。</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">bool</span> is_r_value<span class="br0">(</span><span class="kw4">int</span> <span class="sy3">&amp;&amp;</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="kw4">bool</span> is_r_value<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">int</span> <span class="sy3">&amp;</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">false</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="kw4">void</span> test<span class="br0">(</span><span class="kw4">int</span> <span class="sy3">&amp;&amp;</span> i<span class="br0">)</span>
<span class="br0">{</span>
    is_r_value<span class="br0">(</span>i<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// i 為具名變數，即使被宣告成右值也不會被認定是右值。</span>
    is_r_value<span class="br0">(</span>std<span class="sy4">::</span><span class="me2">move</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy3">&amp;</span><span class="sy1">&gt;</span><span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 使用 std::move&lt;T&gt;() 取得右值。</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>由于右值引用的用语特性以及对于左值引用(L-value references;regular references)的某些用语修正，右值引用允许开发者提供完美转发 (perfect function forwarding)。当与<a href="#.E4.B8.8D.E5.AE.9A.E9.95.B7.E5.8F.83.E6.95.B8.E6.A8.A1.E6.9D.BF">变长参数模板</a>结合，这项能力允许函数模板能够完美地转送引用给其他接受这些特定引用的函数。最大的用处在于转送构造函数参数，创造出能够自动为这些特定引用调用正确构造函数的工厂函数(factory function)。</p>
<h3><span class="mw-headline" id=".E6.B3.9B.E5.8C.96.E7.9A.84.E5.B8.B8.E6.95.B8.E8.A1.A8.E7.A4.BA.E5.BC.8F">泛化的常数表示式</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=5" title="编辑段落：泛化的常数表示式">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>C++ 本来就已具备常数表示式(constant expression)的概念。像是 <tt>3+4</tt> 
总是会产生相同的结果并且没有任何的副作用。常数表示式对编译器来说是优化的机会，编译器时常在编译期运行它们并且将值存入程序中。同样地，在许多场合
下，C++ 规格要求使用常数表示式。例如在数组大小的定义上，以及枚举值(enumerator values)都要求必须是常数表示式。</p>
<p>然而，常数表示式总是在遇上了函数调用或是对象构造函数时就终结。所以像是以下的例子是不合法的：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">int</span> GetFive<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="kw1">return</span> <span class="nu0">5</span><span class="sy4">;</span><span class="br0">}</span>
 
<span class="kw4">int</span> some_value<span class="br0">[</span>GetFive<span class="br0">(</span><span class="br0">)</span> <span class="sy2">+</span> <span class="nu0">5</span><span class="br0">]</span>；<span class="co1">// 欲產生 10 個整數的陣列。 不合法的 C++ 寫法</span>
</pre></div>
</div>
<p>这不是合法的 C++，因为 <tt>GetFive() + 5</tt> 并不是常数表示式。编译器无从得知 <tt>GetFive</tt> 实际上在运行期是常数。理论上而言，这个函数可能会影响全局参数，或者调用其他的非运行期(non-runtime)常数函数等。</p>
<p>C++11引进关键字 <tt>constexpr</tt> 允许用户保证函数或是对象构造函数是编译期常数。以上的例子可以被写成像是下面这样：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">constexpr <span class="kw4">int</span> GetFive<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="kw1">return</span> <span class="nu0">5</span><span class="sy4">;</span><span class="br0">}</span>
 
<span class="kw4">int</span> some_value<span class="br0">[</span>GetFive<span class="br0">(</span><span class="br0">)</span> <span class="sy2">+</span> <span class="nu0">5</span><span class="br0">]</span>；<span class="co1">// 欲產生 10 個整數的陣列。合法的C++11寫法</span>
</pre></div>
</div>
<p>这使得编译器能够了解并去验证 <tt>GetFive</tt> 是个编译期常数。</p>
<p>对函数使用 <tt>constexpr</tt> 在函数可以做的事上面加上了非常严格的条件。首先，该函数的回返值类型不能为 void。第二点，函数的内容必须依照 "return <i>expr</i>" 的形式。第三点，在引用取代后，<tt>expr</tt> 必须是个常数表示式。这些常数表示式只能够调用其他被定义为 <tt>constexpr</tt> 的函数，或是其他常数表示式的数据参数。 最后一点，有着这样标签的函数直到在该编译单元内被定义之前是不能够被调用的。</p>
<p>参数也可以被定义为常数表示式值：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">constexpr <span class="kw4">double</span> forceOfGravity <span class="sy1">=</span> <span class="nu16">9.8</span><span class="sy4">;</span>
constexpr <span class="kw4">double</span> moonGravity <span class="sy1">=</span> forceOfGravity <span class="sy2">/</span> <span class="nu16">6.0</span><span class="sy4">;</span>
</pre></div>
</div>
<p>常数表示式的数据参数是隐式的常数。他们可以只存储常数表示式或常数表示式构造函数的结果。</p>
<p>为了从用户自定类型(user-defined type)构造常数表示式的数据参数，构造函数也可以被声明成 <tt>constexpr</tt>。与常数表示式函数一样，常数表示式的构造函数必须在该编译单元内使用之前被定义。他必须有着空的函数本体。它必须用常数表示式初始化他的成员(member)。而这种类型的析构函数应当是无意义的(trivial)，什么事都不做。</p>
<p>复制 constexpr 构造起来的类型也应该被定义为 <tt>constexpr</tt>，这样可以让他们从常数表示式的函数以值传回。类型的任何成员函数，像是复制构造函数、重载的运算符等等，只要他们符合常数表示式函数的定义，都可以被声明成 <tt>constexpr</tt>。这使得编译器能够在编译期进行类型的复制、对他们施行运算等等。</p>
<p>常数表示式函数或构造函数，可以以非常数表示式(non-constexpr)参数调用。就如同 constexpr 整数字面值能够指派给 
non-constexpr 参数，constexpr 函数也可以接受 non-constexpr 参数，其结果存储于 non-constexpr
 参数。constexpr 关键字只有当表示式的成员都是 constexpr，才允许编译期常数性的可能。</p>
<h3><span class="mw-headline" id=".E5.B0.8DPOD.E5.AE.9A.E7.BE.A9.E7.9A.84.E4.BF.AE.E6.AD.A3">对POD定义的修正</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=6" title="编辑段落：对POD定义的修正">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在标准C++，一个结构(struct)为了能够被当成 <a href="http://zh.wikipedia.org/wiki/POD_%28%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%29" title="POD (程序设计)">POD</a>，必须遵守几条规则。有很好的理由使我们想让大量的类型符合这种定义，符合这种定义的类型能够允许产生与C兼容的对象布局(object layout)。然而，C++03的规则太严苛了。</p>
<p>C++11将会放宽关于POD的定义。</p>
<p>当class/struct是<i>极简的(trivial)</i>、属于<i>标准布局(standard-layout)</i>，以及他的所有非静态(non-static)成员都是POD时，会被视为POD。</p>
<p>一个极简的类型或结构符合以下定义：</p>
<ol>
<li>极简的默认构造函数。这可以使用<a href="#.E4.BD.BF.E7.94.A8.E6.88.96.E7.A6.81.E7.94.A8.E7.89.A9.E4.BB.B6.E7.9A.84.E9.A0.90.E8.A8.AD.E5.87.BD.E5.BC.8F">默认构造函数语法</a>，例如<tt>SomeConstructor() = default;</tt></li>
<li>极简的复制构造函数，可使用默认语法(default syntax)</li>
<li>极简的赋值运算符，可使用默认语法(default syntax)</li>
<li>极简的析构函数，不可以是虚拟的(virtual)</li>
</ol>
<p>一个标准布局(standard-layout)的类型或结构符合以下定义：</p>
<ol>
<li>只有非静态的(non-static)数据成员，且这些成员也是符合标准布局的类型</li>
<li>对所有non-static成员有相同的访问控制(public, private, protected)</li>
<li>没有虚函数</li>
<li>没有虚拟基类</li>
<li>只有符合标准布局的基类</li>
<li>没有和第一个定义的non-static成员相同类型的基类</li>
<li>若非没有带有non-static成员的基类，就是最底层(继承最末位)的类型没有non-static数据成员而且至多一个带有non-static成员的基类。基本上，在该类型的继承体系中只会有一个类型带有non-static成员。</li>
</ol>
<h2><span class="mw-headline" id=".E6.A0.B8.E5.BF.83.E8.AA.9E.E8.A8.80.E5.BB.BA.E6.A7.8B.E6.9C.9F.E8.A1.A8.E7.8F.BE.E7.9A.84.E5.8A.A0.E5.BC.B7">核心语言构造期表现的加强</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=7" title="编辑段落：核心语言构造期表现的加强">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id=".E5.A4.96.E9.83.A8.E6.A8.A1.E6.9D.BF">外部模板</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=8" title="编辑段落：外部模板">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在标准C++中，只要在编译单元内遇到被完整定义的模板，编译器都必须将其实例化(instantiate)。这会大大增加编译时间，特别是模板在许多编译单元内使用相同的参数实例化。看起来没有办法告诉C++不要引发模板的实例化。</p>
<p>C++11将会引入外部模板这一概念。C++已经有了强制编译器在特定位置开始实例化的语法：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span> <span class="kw2">class</span> std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>MyClass<span class="sy1">&gt;</span><span class="sy4">;</span>
</pre></div>
</div>
<p>而C++所缺乏的是阻止编译器在某个编译单元内实例化模板的能力。C++11将简单地扩充前文语法如下：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">extern</span> <span class="kw2">template</span> <span class="kw2">class</span> std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>MyClass<span class="sy1">&gt;</span><span class="sy4">;</span>
</pre></div>
</div>
<p>这样就告诉编译器<i>不要</i>在该编译单元内将该模板实例化。</p>
<h2><span class="mw-headline" id=".E6.A0.B8.E5.BF.83.E8.AA.9E.E8.A8.80.E4.BD.BF.E7.94.A8.E6.80.A7.E7.9A.84.E5.8A.A0.E5.BC.B7">核心语言使用性的加强</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=9" title="编辑段落：核心语言使用性的加强">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>这些特色存在的主要目的是为了使C++能够更容易使用。 举凡可以增进类型安全，减少代码重复，不易误用代码之类的。</p>
<h3><span class="mw-headline" id=".E5.88.9D.E5.A7.8B.E5.8C.96.E5.88.97.E8.A1.A8">初始化列表</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=10" title="编辑段落：初始化列表">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>标准C++从C带来了初始化列表(initializer 
list)的概念。这个构想是结构或是数组能够依据成员在该结构内定义的顺序通过给予的一串引用来产生。这些初始化列表是递归的，所以结构的数组或是包含
其他结构的结构可以使用它们。这对静态列表或是仅是把结构初始化为某值而言相当有用。C++有构造函数，能够重复对象的初始化。但单单只有那样并不足以取
代这项特色的所有机能。在C++03中，只允许在严格遵守POD的定义和限制条件的结构及类型上使用这项机能，非POD的类型不能使用，就连相当有用的
STL容器std::vector也不行。</p>
<p>C++11将会把初始化列表的概念绑到类型上，称作<tt>std::initializer_list</tt>。这允许构造函数或其他函数像参数般地使用初始化列表。举例来说：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">class</span> SequenceClass
<span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
  SequenceClass<span class="br0">(</span>std<span class="sy4">::</span><span class="me2">initializer_list</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> list<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>这将允许<tt>SequenceClass</tt>由一连串的整数构造，就像：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">SequenceClass someVar <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">4</span>, <span class="nu0">5</span>, <span class="nu0">6</span><span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>这个构造函数是种特殊的构造函数，称作初始化列表构造函数。有着这种构造函数的类型在统一初始化的时候会被特别对待。</p>
<p>类型<tt>std::initializer_list&lt;&gt;</tt>是个第一级的C++11标准程序库类型。然而他们只能够经由C++11编译器通过{}语法的使用被静态地构造 。这个列表一经构造便可复制，虽然这只是copy-by-reference。初始化列表是常数；一旦被创建，其成员均不能被改变，成员中的数据也不能够被变动。</p>
<p>因为初始化列表是真实类型，除了类型构造函数之外还能够被用在其他地方。正规的函数能够使用初始化列表作为引用。例如：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">void</span> FunctionName<span class="br0">(</span>std<span class="sy4">::</span><span class="me2">initializer_list</span><span class="sy1">&lt;</span><span class="kw4">float</span><span class="sy1">&gt;</span> list<span class="br0">)</span><span class="sy4">;</span>
 
FunctionName<span class="br0">(</span><span class="br0">{</span><span class="nu17">1.0f</span>, <span class="sy2">-</span><span class="nu17">3.45f</span>, <span class="sy2">-</span><span class="nu17">0.4f</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
</pre></div>
</div>
<p>标准容器也能够以这种方式初始化：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">vector<span class="sy1">&lt;</span>string<span class="sy1">&gt;</span> v <span class="sy1">=</span> <span class="br0">{</span> <span class="st0">"xyzzy"</span>, <span class="st0">"plugh"</span>, <span class="st0">"abracadabra"</span> <span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<h3><span class="mw-headline" id=".E7.B5.B1.E4.B8.80.E7.9A.84.E5.88.9D.E5.A7.8B.E5.8C.96">统一的初始化</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=11" title="编辑段落：统一的初始化">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>标准 C++ 在初始化类型方面有着许多问题。初始化类型有数种方法，而且交换使用时不会都产生相同结果。传统的构造函数语法，看起来像是函数声明，而且为了能使编译器不会弄错必须采取一些步骤。只有集合体和 POD 类型能够被集合式的初始化(使用 <code>SomeType var = {/*stuff*/};</code>).</p>
<p>C++11 将会提供一种统一的语法初始化任意的对象，它扩充了初始化列表语法：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> BasicStruct
<span class="br0">{</span>
 <span class="kw4">int</span> x<span class="sy4">;</span>
 <span class="kw4">float</span> y<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">struct</span> AltStruct
<span class="br0">{</span>
  AltStruct<span class="br0">(</span><span class="kw4">int</span> _x, <span class="kw4">float</span> _y<span class="br0">)</span> <span class="sy4">:</span> x<span class="br0">(</span>_x<span class="br0">)</span>, y<span class="br0">(</span>_y<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
 
<span class="kw2">private</span><span class="sy4">:</span>
  <span class="kw4">int</span> x<span class="sy4">;</span>
  <span class="kw4">float</span> y<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
BasicStruct var1<span class="br0">{</span><span class="nu0">5</span>, <span class="nu17">3.2f</span><span class="br0">}</span><span class="sy4">;</span>
AltStruct var2<span class="br0">{</span><span class="nu0">2</span>, <span class="nu17">4.3f</span><span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p><tt>var1</tt> 的初始化的运作就如同 C-style 
的初始化列表。每个公开的参数将被对应于初始化列表的值给初始化。隐式类型转换会在需要的时候被使用，这里的隐式类型转换不会产生范围缩限 
(narrowing)。要是不能够转换，编译便会失败。(范围缩限 (narrowing)：转换后的类型无法表示原类型。如将 32-bit 
的整数转换为 16-bit 或 8-bit 整数，或是浮点数转换为整数。) <tt>var2</tt> 的初始化则是简单地调用构造函数。</p>
<p>统一的初始化构造能够免除具体指定特定类型的必要：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> IdString
<span class="br0">{</span>
  std<span class="sy4">::</span><span class="me2">string</span> name<span class="sy4">;</span>
  <span class="kw4">int</span> identifier<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
IdString var3<span class="br0">{</span><span class="st0">"SomeName"</span>, <span class="nu0">4</span><span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>该语法将会使用 <tt>const char *</tt> 参数初始化 <tt>std::string</tt> 。你也可以做像下面的事：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">IdString GetString<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">return</span> <span class="br0">{</span><span class="st0">"SomeName"</span>, <span class="nu0">4</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// 注意這裡不需要明確的型別</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>统一初始化不会取代构造函数语法。仍然会有需要用到构造函数语法的时候。如果一个类型拥有初始化列表构造函数(<tt>TypeName(initializer_list&lt;SomeType&gt;);</tt>)，而初始化列表符合 sequence 构造函数的类型，那么它比其他形式的构造函数的优先权都来的高。C++11 版本的 <tt>std::vector</tt> 将会有初始化列表构造函数。这表示：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> theVec<span class="br0">{</span><span class="nu0">4</span><span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>这将会调用初始化列表构造函数，而不是调用<tt>std::vector</tt>只接受一个尺寸参数产生相应尺寸 vector 的构造函数。要使用这个构造函数，用户必须直接使用标准的构造函数语法。</p>
<h3><span class="mw-headline" id=".E5.9E.8B.E5.88.A5.E6.8E.A8.E5.B0.8E">类型推导</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=12" title="编辑段落：类型推导">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在标准 C++(和 C )，使用参数必须明确的指出其类型。然而，随着模版类型的出现以及<a href="http://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E8%B6%85%E7%B7%A8%E7%A8%8B" title="模板元编程">模板元编程</a>的技巧，某物的类型，特别是函数定义明确的回返类型，就不容易表示。在这样的情况下，将中间结果存储于参数是件困难的事，可能会需要知道特定的元编程程序库的内部情况。</p>
<p>C++11 提供两种方法缓解上述所遇到的困难。首先，有被明确初始化的参数可以使用 <tt>auto</tt> 关键字。这会依据该初始化子(initializer)的具体类型产生参数：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">auto</span> someStrangeCallableType <span class="sy1">=</span> boost<span class="sy4">::</span><span class="me2">bind</span><span class="br0">(</span><span class="sy3">&amp;</span>SomeFunction, _2, _1, someObject<span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">auto</span> otherVariable <span class="sy1">=</span> <span class="nu0">5</span><span class="sy4">;</span>
</pre></div>
</div>
<p><tt>someStrangeCallableType</tt> 的类型就是模板函数 <code>boost::bind</code> 对特定引用所回返的类型。作为编译器语义分析责任的一部份，这个类型能够简单地被编译器决定，但用户要通过查看来判断类型就不是那么容易的一件事了。</p>
<p><tt>otherVariable</tt> 的类型同样也是定义明确的，但用户很容易就能判别。它是个 <tt>int</tt>(整数)，就和整数字面值的类型一样。</p>
<p>除此之外，<tt>decltype</tt> 能够被用来在编译期决定一个表示式的类型。举例：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">int</span> someInt<span class="sy4">;</span>
decltype<span class="br0">(</span>someInt<span class="br0">)</span> otherIntegerVariable <span class="sy1">=</span> <span class="nu0">5</span><span class="sy4">;</span>
</pre></div>
</div>
<p><tt>decltype</tt> 和 <tt>auto</tt> 一起使用会更为有用，因为 auto 参数的类型只有编译器知道。然而 <tt>decltype</tt> 对于那些大量运用运算符重载和特化的类型的代码的表示也非常有用。</p>
<p><code>auto</code> 对于减少冗赘的代码也很有用。举例而言，程序员不用写像下面这样：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw1">for</span> <span class="br0">(</span>vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> itr <span class="sy1">=</span> myvec.<span class="me1">cbegin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> itr <span class="sy3">!</span><span class="sy1">=</span> myvec.<span class="me1">cend</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>itr<span class="br0">)</span>
</pre></div>
</div>
<p>而可以用更简短的</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw1">for</span> <span class="br0">(</span><span class="kw4">auto</span> itr <span class="sy1">=</span> myvec.<span class="me1">cbegin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> itr <span class="sy3">!</span><span class="sy1">=</span> myvec.<span class="me1">cend</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>itr<span class="br0">)</span>
</pre></div>
</div>
<p>这项差异随着程序员开始嵌套容器而更为显著，虽然在这种情况下 <code>typedef</code> 是一个减少代码的好方法。</p>
<p><tt>decltype</tt> 所表示的类型可以和 <tt>auto</tt> 推导出来的不同。</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="co2">#include &lt;vector&gt;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw4">const</span> std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="kw4">auto</span> a <span class="sy1">=</span> v<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>；<span class="co1">// a 為 int 型別</span>
  decltype（v<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span> b <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>   <span class="co1">// b 為 const int&amp; 型別，即</span>
                      <span class="co1">// std::vector&lt;int&gt;::operator[]（size_type）const 的回返型別</span>
  <span class="kw4">auto</span> c <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>         <span class="co1">// c 為 int 型別</span>
  <span class="kw4">auto</span> d <span class="sy1">=</span> c<span class="sy4">;</span>         <span class="co1">// d 為 int 型別      </span>
  decltype<span class="br0">(</span>c<span class="br0">)</span> e<span class="sy4">;</span>      <span class="co1">// e 為 int 型別，c 實體的型別 </span>
  decltype<span class="br0">(</span><span class="br0">(</span>c<span class="br0">)</span><span class="br0">)</span> f <span class="sy1">=</span> e<span class="sy4">;</span> <span class="co1">// f 為 int&amp; 型別，因為（c）是左值</span>
  decltype<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span> g<span class="sy4">;</span>      <span class="co1">// g為int型別，因為0是右值</span>
<span class="br0">}</span>
</pre></div>
</div>
<h3><span class="mw-headline" id=".E4.BB.A5.E7.AF.84.E5.9C.8D.E7.82.BA.E5.9F.BA.E7.A4.8E.E7.9A.84_for_.E8.BF.B4.E5.9C.88">以范围为基础的 for 循环</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=13" title="编辑段落：以范围为基础的 for 循环">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Boost C++ 定义了许多"范围 (range) "的概念。范围表现有如受控制的列表 (list)，持有容器中的两点。有序容器是范围概念的超集 (superset)，有序容器中的两个<a href="http://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3%E5%99%A8" title="迭代器">迭代器</a> (iterator) 也能定义一个范围。这些概念以及操作的算法，将被并入 C++11 标准程序库。不过 C++11 将会以语言层次的支持来提供范围概念的效用。</p>
<p><tt>for</tt> 述句将允许简单的范围迭代：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">int</span> my_array<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span><span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> <span class="sy3">&amp;</span>x <span class="sy4">:</span> my_array<span class="br0">)</span>
<span class="br0">{</span>
  x <span class="sy2">*</span><span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>上面 <tt>for</tt> 述句的第一部份定义被用来做范围迭代的参数，就像被声明在一般 for 循环的参数一样，其作用域仅只于循环的范围。而在":"之后的第二区块，代表将被迭代的范围。这样一来，就有了能够允许 C-style 数组被转换成范围概念的概念图。这可以是 <tt>std::vector</tt>，或是其他符合范围概念的对象。</p>
<h3><span class="mw-headline" id="Lambda.E5.87.BD.E5.BC.8F.E8.88.87.E8.A1.A8.E7.A4.BA.E5.BC.8F">Lambda函数与表示式</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=14" title="编辑段落：Lambda函数与表示式">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在标准 C++，特别是当使用 C++ 标准程序库算法函数诸如 <tt>sort</tt> 和 <tt>find</tt>，用户经常希望能够
在算法函数调用的附近定义一个临时的述部函数(又称谓词函数，predicate 
function)。由于语言本身允许在函数内部定义类型，可以考虑使用函数对象，然而这通常既麻烦又冗赘，也阻碍了代码的流程。此外，标准 C++ 
不允许定义于函数内部的类型被用于模板，所以前述的作法是不可行的。</p>
<p>C++11 对 <a href="http://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" title="Λ演算">lambda</a> 的支持可以解决上述问题。</p>
<p>一个 lambda 函数可以用如下的方式定义:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">int</span> x, <span class="kw4">int</span> y<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> x <span class="sy2">+</span> y<span class="sy4">;</span> <span class="br0">}</span>
</pre></div>
</div>
<p>这个不具名函数的回返类型是 <tt>decltype(x+y)</tt>。只有在 lambda 函数符合"return <i>expression</i>"的形式下，它的回返类型才能被忽略。在前述的情况下，lambda 函数仅能为一个述句。</p>
<p>在一个更为复杂的例子中，回返类型可以被明确的指定如下：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">int</span> x, <span class="kw4">int</span> y<span class="br0">)</span> <span class="sy2">-</span><span class="sy1">&gt;</span> <span class="kw4">int</span> <span class="br0">{</span> <span class="kw4">int</span> z <span class="sy1">=</span> x <span class="sy2">+</span> y<span class="sy4">;</span> <span class="kw1">return</span> z <span class="sy2">+</span> x<span class="sy4">;</span> <span class="br0">}</span>
</pre></div>
</div>
<p>本例中，一个临时的参数 <tt>z</tt> 被创建用来存储中间结果。如同一般的函数，<tt>z</tt> 的值不会保留到下一次该不具名函数再次被调用时。</p>
<p>如果 lambda 函数没有传回值(例如 <tt>void</tt> )，其回返类型可被完全忽略。</p>
<p>定义在与 lambda 函数相同作用域的参数引用也可以被使用。这种的参数集合一般被称作 closure (<a href="http://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29" title="闭包 (计算机科学)">闭包</a>)。</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="br0">[</span><span class="br0">]</span>  <span class="co1">// 沒有定義任何變數。使用未定義變數會導致錯誤。</span>
<span class="br0">[</span>x, <span class="sy3">&amp;</span>y<span class="br0">]</span> <span class="co1">// x 以傳值方式傳入(預設)，y 以傳參考方式傳入。</span>
<span class="br0">[</span><span class="sy3">&amp;</span><span class="br0">]</span>   <span class="co1">// 任何被使用到的外部變數皆隱式地以參考方式加以引用。</span>
<span class="br0">[</span><span class="sy1">=</span><span class="br0">]</span>   <span class="co1">// 任何被使用到的外部變數皆隱式地以傳值方式加以引用。</span>
<span class="br0">[</span><span class="sy3">&amp;</span>, x<span class="br0">]</span>   <span class="co1">// x 顯示地以傳值方式加以引用。其餘變數以參考方式加以引用。</span>
<span class="br0">[</span><span class="sy1">=</span>, <span class="sy3">&amp;</span>z<span class="br0">]</span>   <span class="co1">// z 顯示地以參考方式加以引用。其餘變數以傳值方式加以引用。</span>
</pre></div>
</div>
<p>closure 被定义与使用如下:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> someList<span class="sy4">;</span>
<span class="kw4">int</span> total <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
std<span class="sy4">::</span><span class="me2">for_each</span><span class="br0">(</span>someList.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, someList.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, <span class="br0">[</span><span class="sy3">&amp;</span>total<span class="br0">]</span><span class="br0">(</span><span class="kw4">int</span> x<span class="br0">)</span> <span class="br0">{</span>
  total <span class="sy2">+</span><span class="sy1">=</span> x<span class="sy4">;</span>
<span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> total<span class="sy4">;</span>
</pre></div>
</div>
<p>上例可计算 <tt>someList</tt> 元素的总和并将其印出。 参数 <tt>total</tt> 是 lambda 函数 closure 的一部分，同时它以引用方式被传递入谓词函数， 因此它的值可被 lambda 函数改变。</p>
<p>若不使用引用的符号<i>&amp;</i>，则代表参数以传值的方式传入 lambda 函数。 让用户可以用这种表示法明确区分参数传递的方法：传值，或是传引用。 由于 lambda 函数可以不在被声明的地方就地使用(如置入 <tt>std::function</tt> 对象中)； 这种情况下，若参数是以传引用的方式链接到 closure 中，是无意义甚至是危险的行为。</p>
<p>若 lambda 函数只在定义的作用域使用， 则可以用 <tt>[&amp;]</tt> 声明 lambda 函数， 代表所有引用到 stack 中的参数，都是以引用的方式传入， 不必一一显式指明：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> someList<span class="sy4">;</span>
<span class="kw4">int</span> total <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
std<span class="sy4">::</span><span class="me2">for_each</span><span class="br0">(</span>someList.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, someList.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, <span class="br0">[</span><span class="sy3">&amp;</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">int</span> x<span class="br0">)</span> <span class="br0">{</span>
  total <span class="sy2">+</span><span class="sy1">=</span> x<span class="sy4">;</span>
<span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
</pre></div>
</div>
<p>参数传入 lambda 函数的方式可能随实现有所变化，一般期望的方法是 lambda 函数能保留其作用域函数的 stack 指针，借此访问区域参数。</p>
<p>若使用 <tt>[=]</tt> 而非 <tt>[&amp;]</tt>，则代表所有的引用的参数都是传值使用。</p>
<p>对于不同的参数，传值或传引用可以混和使用。 比方说，用户可以让所有的参数都以传引用的方式使用，但带有一个传值使用的参数：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">int</span> total <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw4">int</span> value <span class="sy1">=</span> <span class="nu0">5</span><span class="sy4">;</span>
<span class="br0">[</span><span class="sy3">&amp;</span>, value<span class="br0">]</span><span class="br0">(</span><span class="kw4">int</span> x<span class="br0">)</span> <span class="br0">{</span> total <span class="sy2">+</span><span class="sy1">=</span> <span class="br0">(</span>x <span class="sy2">*</span> value<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p><tt>total</tt> 是传引用的方式传入 lambda 函数，而 <tt>value</tt> 则是传值。</p>
<p>若一个 lambda 函数被定义于某类型的成员函数中，则可以使用该类型对象的引用，并且能够访问其内部的成员。</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="br0">[</span><span class="br0">]</span><span class="br0">(</span>SomeType <span class="sy2">*</span>typePtr<span class="br0">)</span> <span class="br0">{</span> typePtr<span class="sy2">-</span><span class="sy1">&gt;</span>SomePrivateMemberFunction<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>这只有当该 lambda 函数创建的作用域是在 <tt>SomeType</tt> 的成员函数内部时才能运作。</p>
<p>在成员函数中指涉对象的 this 指针，必须要显式的传入 lambda 函数， 否则成员函数中的 lambda 函数无法使用任何该对象的参数或函数。</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="br0">[</span><span class="kw3">this</span><span class="br0">]</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> this<span class="sy2">-</span><span class="sy1">&gt;</span>SomePrivateMemberFunction<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>若是 lambda 函数使用 [&amp;] 或是 [=] 的形式，<tt>this</tt>在 lambda 函数即为可见。</p>
<p>lambda 函数是编译器从属类型的函数对象； 这种类型名称只有编译器自己能够使用。如果用户希望将 lambda 函数作为参数传入，该类型必须是模版类型，或是必须创建一个 <tt>std::function</tt> 去获取 lambda 的值。使用 <tt>auto</tt> 关键字让我们能够存储 lambda 函数：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">auto</span> myLambdaFunc <span class="sy1">=</span> <span class="br0">[</span><span class="kw3">this</span><span class="br0">]</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> this<span class="sy2">-</span><span class="sy1">&gt;</span>SomePrivateMemberFunction<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">auto</span> myOnheapLambdaFunc <span class="sy1">=</span> <span class="kw3">new</span> <span class="kw4">auto</span><span class="br0">(</span><span class="br0">[</span><span class="sy1">=</span><span class="br0">]</span> <span class="br0">{</span> <span class="coMULTI">/*...*/</span> <span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
</pre></div>
</div>
<h3><span class="mw-headline" id=".E8.BF.94.E5.9B.9E.E5.9E.8B.E5.88.A5.E5.BE.8C.E7.BD.AE.E7.9A.84.E5.87.BD.E5.BC.8F.E5.AE.A3.E5.91.8A">回返类型后置的函数声明</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=15" title="编辑段落：回返类型后置的函数声明">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><a href="http://zh.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80" title="C语言" class="mw-redirect">标准C</a> 函数声明语法对于C语言已经足够。 演化自 C 的 C++ 除了 C 的基础语法外，又扩充额外的语法。 然而，当 C++ 变得更为复杂时，它暴露出许多语法上的限制， 特别是针对函数模板的声明。 下面的示例，不是合法的 C++03：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span> <span class="kw2">typename</span> LHS, <span class="kw2">typename</span> RHS<span class="sy1">&gt;</span> 
  Ret AddingFunc<span class="br0">(</span><span class="kw4">const</span> LHS <span class="sy3">&amp;</span>lhs, <span class="kw4">const</span> RHS <span class="sy3">&amp;</span>rhs<span class="br0">)</span> <span class="br0">{</span><span class="kw1">return</span> lhs <span class="sy2">+</span> rhs<span class="sy4">;</span><span class="br0">}</span> <span class="co1">//Ret的型別必須是(lhs+rhs)的型別</span>
</pre></div>
</div>
<p><tt>Ret</tt> 的类型由 <tt>LHS</tt>与<tt>RHS</tt>相加之后的结果的类型来决定。 即使使用 C++11 新加入的 <tt>decltype</tt> 来声明 <tt>AddingFunc</tt> 的回返类型，依然不可行。</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span> <span class="kw2">typename</span> LHS, <span class="kw2">typename</span> RHS<span class="sy1">&gt;</span> 
  decltype<span class="br0">(</span>lhs<span class="sy2">+</span>rhs<span class="br0">)</span> AddingFunc<span class="br0">(</span><span class="kw4">const</span> LHS <span class="sy3">&amp;</span>lhs, <span class="kw4">const</span> RHS <span class="sy3">&amp;</span>rhs<span class="br0">)</span> <span class="br0">{</span><span class="kw1">return</span> lhs <span class="sy2">+</span> rhs<span class="sy4">;</span><span class="br0">}</span> <span class="co1">//不合法的 C++11</span>
</pre></div>
</div>
<p>不合法的原因在于<tt>lhs</tt> 及 <tt>rhs</tt> 在定义前就出现了。 直到剖析器解析到函数原型的后半部，<tt>lhs</tt> 与 <tt>rhs</tt> 才是有意义的。</p>
<p>针对此问题，C++11 引进一种新的函数定义与声明的语法：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span> <span class="kw2">typename</span> LHS, <span class="kw2">typename</span> RHS<span class="sy1">&gt;</span> 
  <span class="kw4">auto</span> AddingFunc<span class="br0">(</span><span class="kw4">const</span> LHS <span class="sy3">&amp;</span>lhs, <span class="kw4">const</span> RHS <span class="sy3">&amp;</span>rhs<span class="br0">)</span> <span class="sy2">-</span><span class="sy1">&gt;</span> decltype<span class="br0">(</span>lhs<span class="sy2">+</span>rhs<span class="br0">)</span> <span class="br0">{</span><span class="kw1">return</span> lhs <span class="sy2">+</span> rhs<span class="sy4">;</span><span class="br0">}</span>
</pre></div>
</div>
<p>这种语法也能套用到一般的函数定义与声明：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> SomeStruct
<span class="br0">{</span>
  <span class="kw4">auto</span> FuncName<span class="br0">(</span><span class="kw4">int</span> x, <span class="kw4">int</span> y<span class="br0">)</span> <span class="sy2">-</span><span class="sy1">&gt;</span> <span class="kw4">int</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">auto</span> SomeStruct<span class="sy4">::</span><span class="me2">FuncName</span><span class="br0">(</span><span class="kw4">int</span> x, <span class="kw4">int</span> y<span class="br0">)</span> <span class="sy2">-</span><span class="sy1">&gt;</span> <span class="kw4">int</span>
<span class="br0">{</span>
  <span class="kw1">return</span> x <span class="sy2">+</span> y<span class="sy4">;</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>关键字 <b>auto</b> 的使用与其在自动类型推导代表不同的意义。</p>
<h3><span class="mw-headline" id=".E7.89.A9.E4.BB.B6.E5.BB.BA.E6.A7.8B.E7.9A.84.E6.94.B9.E8.89.AF">对象构造的改良</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=16" title="编辑段落：对象构造的改良">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在标准C++中，构造函数不能调用其它的构造函数；每个构造函数必须自己初始化所有的成员或是调用一个共用的成员函数。基类的构造函数不能够直接作
为派生类的构造函数；就算基类的构造函数已经足够，每个派生的类型仍必须实现自己的构造函数。类型中non-constant的数据成员不能够在声明的地
方被初始化，它们只能在构造函数中被初始化。 C++11将会提供这些问题的解决方案。</p>
<p>C++11允许构造函数调用其他构造函数，这种做法称作委托或转接(<a href="http://zh.wikipedia.org/w/index.php?title=Delegation&amp;action=edit&amp;redlink=1" class="new" title="Delegation（页面不存在）">delegation</a>)。 仅仅只需要加入少量的代码，就能让数个构造函数之间达成功能复用(reuse)。 <a href="http://zh.wikipedia.org/wiki/Java" title="Java">Java</a>以及<a href="http://zh.wikipedia.org/wiki/C" title="C">C#</a>都有提供这种功能。C++11 语法如下：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">class</span> SomeType <span class="br0">{</span>
  <span class="kw4">int</span> number<span class="sy4">;</span>
  string name<span class="sy4">;</span>
  SomeType<span class="br0">(</span> <span class="kw4">int</span> i, string<span class="sy3">&amp;</span> s <span class="br0">)</span> <span class="sy4">:</span> number<span class="br0">(</span>i<span class="br0">)</span>, name<span class="br0">(</span>s<span class="br0">)</span><span class="br0">{</span><span class="br0">}</span>
<span class="kw2">public</span><span class="sy4">:</span>
  SomeType<span class="br0">(</span> <span class="br0">)</span>           <span class="sy4">:</span> SomeType<span class="br0">(</span> <span class="nu0">0</span>, <span class="st0">"invalid"</span> <span class="br0">)</span><span class="br0">{</span><span class="br0">}</span>
  SomeType<span class="br0">(</span> <span class="kw4">int</span> i <span class="br0">)</span>     <span class="sy4">:</span> SomeType<span class="br0">(</span> i, <span class="st0">"guest"</span> <span class="br0">)</span><span class="br0">{</span><span class="br0">}</span>
  SomeType<span class="br0">(</span> string<span class="sy3">&amp;</span> s <span class="br0">)</span> <span class="sy4">:</span> SomeType<span class="br0">(</span> <span class="nu0">1</span>, s <span class="br0">)</span><span class="br0">{</span> PostInit<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>C++03中，构造函数运行退出代表对象构造完成； 而允许使用转接构造函数的 C++11 则是以"任何"一个构造函数退出代表构造完成。 使用转接的构造函数，函数本体中的代码将于被转接的构造函数完成后继续运行(如上例的 <tt>PostInit()</tt>)。 若基底类型使用了转接构造函数，则派生类的构造函数会在"所有"基底类型的构造函数都完成后， 才会开始运行。</p>
<p>C++11 允许派生类手动继承基底类型的构造函数， 编译器可以使用基底类型的构造函数完成派生类的构造。 
而将基类的构造函数带入派生类的动作， 无法选择性地部分带入， 要不就是继承基类全部的构造函数，要不就是一个都不继承(不手动带入)。 
此外，若牵涉到多重继承，从多个基底类型继承而来的构造函数不可以有相同的函数签名(signature)。 
而派生类的新加入的构造函数也不可以和继承而来的基底构造函数有相同的函数签名，因为这相当于重复声明。</p>
<p>语法如下：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">class</span> BaseClass
<span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
  BaseClass<span class="br0">(</span><span class="kw4">int</span> iValue<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw2">class</span> DerivedClass <span class="sy4">:</span> <span class="kw2">public</span> BaseClass
<span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
  <span class="kw2">using</span> BaseClass<span class="sy4">::</span><span class="me2">BaseClass</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>此语法等同于 DerivedClass 声明一个<tt>DerivedClass(int)</tt> 的构造函数。 同时也因为 DerivedClass 有了一个继承而来的构造函数，所以不会有默认构造函数。</p>
<p>另一方面，C++11可以使用以下的语法完成成员初始化：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">class</span> SomeClass
<span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
  SomeClass<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">explicit</span> SomeClass<span class="br0">(</span><span class="kw4">int</span> iNewValue<span class="br0">)</span> <span class="sy4">:</span> iValue<span class="br0">(</span>iNewValue<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
 
<span class="kw2">private</span><span class="sy4">:</span>
  <span class="kw4">int</span> iValue <span class="sy1">=</span> <span class="nu0">5</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>若是构造函数中没有设置<tt>iValue</tt>的初始值，则会采用类定义中的成员初始化，令<tt>iValue</tt>初值为5。在上例中，无参数版本的构造函数，<tt>iValue</tt>便采用默认所定义的值； 而带有一个整数参数的构造函数则会以指定的值完成初始化。</p>
<p>成员初始化除了上例中的赋值形式(使用"=")外，也可以采用构造函数以及统一形的初始化(uniform initialization，使用"{}")。</p>
<h3><span class="mw-headline" id=".E9.A1.AF.E5.BC.8F.E8.99.9B.E5.87.BD.E6.95.B8.E9.87.8D.E8.BC.89">显式虚函数重载</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=17" title="编辑段落：显式虚函数重载">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在 C++ 里，在子类中容易意外的重载虚函数。举例来说:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> Base <span class="br0">{</span>
    <span class="kw2">virtual</span> <span class="kw4">void</span> some_func<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">struct</span> Derived <span class="sy4">:</span> Base <span class="br0">{</span>
    <span class="kw4">void</span> some_func<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p><code>Derived::some_func</code> 的真实意图为何? 程序员真的试图重载该虚函数，或这只是意外? 这也可能是 <code>base</code> 的维护者在其中加入了一个与 <code>Derived::some_func</code> 同名且拥有相同签名的虚函数。</p>
<p>另一个可能的状况是，当基类中的虚函数的签名被改变，子类中拥有旧签名的函数就不再重载该虚函数。因此，如果程序员忘记修改所有子类，运行期将不会正确调用到该虚函数正确的实现。</p>
<p>C++11 将加入支持用来防止上述情形产生，并在编译期而非运行期捕获此类错误。为保持向后兼容，此功能将是选择性的。其语法如下:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> Base <span class="br0">{</span>
    <span class="kw2">virtual</span> <span class="kw4">void</span> some_func<span class="br0">(</span><span class="kw4">float</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">struct</span> Derived <span class="sy4">:</span> Base <span class="br0">{</span>
    <span class="kw2">virtual</span> <span class="kw4">void</span> some_func<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> override<span class="sy4">;</span>   <span class="co1">// 錯誤格式: Derive::some_func 並沒有 override Base::some_func</span>
    <span class="kw2">virtual</span> <span class="kw4">void</span> some_func<span class="br0">(</span><span class="kw4">float</span><span class="br0">)</span> override<span class="sy4">;</span> <span class="co1">// OK：顯式改寫</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>编译器会检查基底类型是否存在一虚拟函数，与派生类中带有声明<code>override</code> 的虚拟函数，有相同的函数签名(signature)；若不存在，则会回报错误。</p>
<p>C++11 也提供指示字<code>final</code>，用来避免类型被继承，或是基底类型的函数被改写：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> Base1 final <span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">struct</span> Derived1 <span class="sy4">:</span> Base1 <span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// 錯誤格式: class Base1 已標明為 final</span>
 
<span class="kw4">struct</span> Base2 <span class="br0">{</span>
    <span class="kw2">virtual</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> final<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">struct</span> Derived2 <span class="sy4">:</span> Base2 <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 錯誤格式: Base2::f 已標明為 final</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>以上的示例中，<code>virtual void f() final;</code>声明一新的虚拟函数，同时也表明禁止派生函数改写原虚拟函数。</p>
<p><code>override</code>与<code>final</code>都不是语言关键字(keyword)，只有在特定的位置才有特别含意，其他地方仍旧可以作为一般指示字(identifier)使用。</p>
<h3><span class="mw-headline" id=".E7.A9.BA.E6.8C.87.E6.A8.99">空指针</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=18" title="编辑段落：空指针">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>早在 1972 年，C语言诞生的初期，常数 <a href="http://zh.wikipedia.org/wiki/0" title="0">0</a> 带有常数及空指针的双重身分。 C 使用 preprocessor macro <code>NULL</code> 表示空指针， 让 <code>NULL</code> 及 <code>0</code> 分别代表空指针及常数 0。 <code>NULL</code> 可被定义为 <code>((void*)0)</code> 或是 <code>0</code>。</p>
<p>C++ 并不采用 C 的规则，不允许将 <code>void*</code> 隐式转换为其他类型的指针。 为了使代码 <code>char* c = NULL;</code> 能通过编译，NULL 只能定义为 <code>0</code>。 这样的决定使得函数重载无法区分代码的语义：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">void</span> foo<span class="br0">(</span><span class="kw4">char</span> <span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">void</span> foo<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>
</pre></div>
</div>
<p>C++ 建议 <code>NULL</code> 应当定义为 <code>0</code>，所以<code>foo(NULL);</code> 将会调用 <code>foo(int)</code>， 这并不是程序员想要的行为，也违反了代码的直观性。0 的歧义在此处造成困扰。</p>
<p>C++11 引入了新的关键字来代表空指针常数：<code>nullptr</code>，将空指针和整数 0 的概念拆开。 <code>nullptr</code> 的类型为<code>nullptr_t</code>，能隐式转换为任何指针或是成员指针的类型，也能和它们进行相等或不等的比较。 而<code>nullptr</code>不能隐式转换为整数，也不能和整数做比较。</p>
<p>为了向下兼容，<code>0</code> 仍可代表空指针常数。</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">char</span><span class="sy2">*</span> pc <span class="sy1">=</span> nullptr<span class="sy4">;</span>     <span class="co1">// OK</span>
<span class="kw4">int</span> <span class="sy2">*</span> pi <span class="sy1">=</span> nullptr<span class="sy4">;</span>     <span class="co1">// OK</span>
<span class="kw4">int</span>    i <span class="sy1">=</span> nullptr<span class="sy4">;</span>     <span class="co1">// error</span>
 
foo<span class="br0">(</span>pc<span class="br0">)</span><span class="sy4">;</span>           <span class="co1">// 呼叫 foo(char *)</span>
</pre></div>
</div>
<h3><span class="mw-headline" id=".E5.BC.B7.E5.9E.8B.E5.88.A5.E5.88.97.E8.88.89">强类型枚举</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=19" title="编辑段落：强类型枚举">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在标准C++中，枚举类型不是类型安全的。枚举类型被视为整数，这使得两种不同的枚举类型之间可以进行比较。C++03 
唯一提供的安全机制是一个整数或一个枚举型值不能隐式转换到另一个枚举别型。 此外，枚举所使用整数类型及其大小都由实现方法定义，皆无法明确指定。 
最后，枚举的名称全数暴露于一般范围中，因此两个不同的枚举，不可以有相同的枚举名。 (好比 <tt>enum Side{ Right, Left };</tt> 和 <tt>enum Thing{ Wrong, Right };</tt> 不能一起使用。)</p>
<p>C++11 引进了一种特别的 "枚举类"，可以避免上述的问题。使用 <tt>enum class</tt> 的语法来声明：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">enum</span> <span class="kw2">class</span> Enumeration
<span class="br0">{</span>
  Val1,
  Val2,
  Val3 <span class="sy1">=</span> <span class="nu0">100</span>,
  Val4 <span class="coMULTI">/* = 101 */</span>,
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>此种枚举为类型安全的。枚举类型不能隐式地转换为整数；也无法与整数数值做比较。 (表示式 <code>Enumeration::Val4 == 101</code> 会触发编译期错误)。</p>
<p>枚举类型所使用类型必须显式指定。在上面的示例中，使用的是默认类型 <tt>int</tt>，但也可以指定其他类型：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">enum</span> <span class="kw2">class</span> Enum2 <span class="sy4">:</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> <span class="br0">{</span>Val1, Val2<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>枚举类型的语汇范围(scoping)定义于枚举类型的名称范围中。 使用枚举类型的枚举名时，必须明确指定其所属范围。 由前述枚举类型 Enum2 为例，<tt>Enum2::Val1</tt>是有意义的表示法， 而单独的 <tt>Val1</tt> 则否。</p>
<p>此外，C++11 允许为传统的枚举指定使用类型：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">enum</span> Enum3 <span class="sy4">:</span> <span class="kw4">unsigned</span> <span class="kw4">long</span> <span class="br0">{</span>Val1 <span class="sy1">=</span> <span class="nu0">1</span>, Val2<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>枚举名 <tt>Val1</tt> 定义于 Enum3 的枚举范围中(Enum3::Val1)，但为了兼容性， <tt>Val1</tt> 仍然可以于一般的范围中单独使用。</p>
<p>在 C++11 中，枚举类型的前置声明 (forward declaration) 也是可行的，只要使用可指定类型的新式枚举即可。 之前的 C++ 无法写出枚举的前置声明，是由于无法确定枚举参数所占的空间大小， C++11 解决了这个问题：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">enum</span> Enum1<span class="sy4">;</span>                     <span class="co1">// 不合法的 C++ 與 C++11; 無法判別大小</span>
<span class="kw2">enum</span> Enum2 <span class="sy4">:</span> <span class="kw4">unsigned</span> <span class="kw4">int</span><span class="sy4">;</span>      <span class="co1">// 合法的 C++11</span>
<span class="kw2">enum</span> <span class="kw2">class</span> Enum3<span class="sy4">;</span>               <span class="co1">// 合法的 C++11，列舉類別使用預設型別 int </span>
<span class="kw2">enum</span> <span class="kw2">class</span> Enum4<span class="sy4">:</span> <span class="kw4">unsigned</span> <span class="kw4">int</span><span class="sy4">;</span> <span class="co1">// 合法的 C++11</span>
<span class="kw2">enum</span> Enum2 <span class="sy4">:</span> <span class="kw4">unsigned</span> <span class="kw4">short</span><span class="sy4">;</span>    <span class="co1">// 不合法的 C++11，Enum2 已被聲明為 unsigned int</span>
</pre></div>
</div>
<h3><span class="mw-headline" id=".E8.A7.92.E6.8B.AC.E8.99.9F">角括号</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=20" title="编辑段落：角括号">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>标准 C++ 的剖析器一律将 "&gt;&gt;" 视为右移运算符。 但在样板定义式中，绝大多数的场合其实都代表两个连续右角括号。 为了避免剖析器误判，撰码时不能把右角括号连着写。</p>
<p>C++11 变更了剖析器的解读规则；当遇到连续的右角括号时，优先解析右角括号为样板引用的退出符号。 如果解读过程中出现普通括号("(" 与 ")")，这条规则产生变化：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw4">bool</span> bTest<span class="sy1">&gt;</span> SomeType<span class="sy4">;</span>
std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>SomeType<span class="sy1">&lt;</span><span class="nu0">1</span><span class="sy1">&gt;</span><span class="nu0">2</span><span class="sy1">&gt;&gt;</span> x1<span class="sy4">;</span>   <span class="co1">// 解讀為 std::vector of "SomeType&lt;true&gt; 2&gt;"，</span>
                                 <span class="co1">// 非法的表示式， 整數 1 被轉換為 bool 型別 true</span>
std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span>SomeType<span class="sy1">&lt;</span><span class="br0">(</span><span class="nu0">1</span><span class="sy1">&gt;</span><span class="nu0">2</span><span class="br0">)</span><span class="sy1">&gt;&gt;</span> x1<span class="sy4">;</span> <span class="co1">// 解讀為 std::vector of "SomeType&lt;false&gt;",</span>
                                 <span class="co1">// 合法的 C++11 表示式， (1&gt;2) 被轉換為 bool 型別 false</span>
</pre></div>
</div>
<h3><span class="mw-headline" id=".E9.A1.AF.E5.BC.8F.E5.9E.8B.E5.88.A5.E8.BD.89.E6.8F.9B.E5.AD.90">显式类型转换子</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=21" title="编辑段落：显式类型转换子">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>C++ 为了避免用户自定的单引用构造函数被当成隐式类型转换子，引入了关键字 <tt>explicit</tt> 修饰字。 但是，在编译器对对象调用隐式类型转换的部分，则没有任何着墨。 比方说，一个 smart pointer 类型具有一个<tt>operator bool()</tt>， 被定义成若该 smart pointer 保管任何资源或指针，则传回 true，反之传回 false。 遇到这样的代码时：<tt>if(smart_ptr_variable)</tt>，编译器可以借由 <tt>operator bool()</tt> 隐式转换成布尔值， 和测试原生指针的方法一样。 但是这类隐式转换同样也会发生在非预期之处。由于 C++ 的 <tt>bool</tt> 类型也是算数类型，能隐式换为整数甚至是浮点数。 拿对象转换出的布尔值做布尔运算以外的数学运算，往往不是程序员想要的。</p>
<p>在 C++11 中，关键字 <tt>explicit</tt> 修饰符也能套用到类型转换子上。如同构造函数一样，它能避免类型转换子被隐式转换调用。但 C++11 特别针对布尔值转换提出规范，在 <tt>if</tt> 条件式，循环，逻辑运算等需要布尔值的地方，编译器能为符合规范的表示式调用用户自定的布尔类型转换子。</p>
<h3><span class="mw-headline" id=".E6.A8.A1.E6.9D.BF.E7.9A.84.E5.88.A5.E5.90.8D">模板的别名</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=22" title="编辑段落：模板的别名">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在进入这个主题之前，各位应该先弄清楚“模板”和“类型”本质上的不同。class template (类型模板，是模板)是用来产生 template class (模板类型，是类型)。<br>
在标准 C++，<code>typedef</code> 可定义模板类型一个新的类型名称，但是不能够使用 <code>typedef</code> 来定义模板的别名。举例来说：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span> <span class="kw2">typename</span> first, <span class="kw2">typename</span> second, <span class="kw4">int</span> third<span class="sy1">&gt;</span>
<span class="kw2">class</span> SomeType<span class="sy4">;</span>
 
<span class="kw2">template</span><span class="sy1">&lt;</span> <span class="kw2">typename</span> second<span class="sy1">&gt;</span>
<span class="kw4">typedef</span> SomeType<span class="sy1">&lt;</span>OtherType, second, <span class="nu0">5</span><span class="sy1">&gt;</span> TypedefName<span class="sy4">;</span> <span class="co1">// 在C++是不合法的</span>
</pre></div>
</div>
<p>这不能够通过编译。</p>
<p>为了定义模板的别名，C++11 将会增加以下的语法：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span> <span class="kw2">typename</span> first, <span class="kw2">typename</span> second, <span class="kw4">int</span> third<span class="sy1">&gt;</span>
<span class="kw2">class</span> SomeType<span class="sy4">;</span>
 
<span class="kw2">template</span><span class="sy1">&lt;</span> <span class="kw2">typename</span> second<span class="sy1">&gt;</span>
<span class="kw2">using</span> TypedefName <span class="sy1">=</span> SomeType<span class="sy1">&lt;</span>OtherType, second, <span class="nu0">5</span><span class="sy1">&gt;</span><span class="sy4">;</span>
</pre></div>
</div>
<p><tt>using</tt> 也能在 C++11 中定义一般类型的别名，等同 <tt>typedef</tt>：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">typedef</span> <span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>PFD<span class="br0">)</span><span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><span class="sy4">;</span>		<span class="co1">// 傳統語法</span>
<span class="kw2">using</span> PFD <span class="sy1">=</span> <span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><span class="sy4">;</span>		<span class="co1">// 新增語法</span>
</pre></div>
</div>
<h3><span class="mw-headline" id=".E7.84.A1.E9.99.90.E5.88.B6.E7.9A.84unions">无限制的unions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=23" title="编辑段落：无限制的unions">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在标准 C++ 中，并非任意的类型都能做为 union 的成员。比方说，带有 non-trivial 构造函数的类型就不能是 union 
的成员。在新的标准里，卸载了所有对 union 的使用限制，除了其成员仍然不能是引用类型。 这一改变使得 union 
更强大，更有用，也易于使用。<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[1]</a></sup></p>
<p>以下为 C++11 中 union 使用的简单样例：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> point
<span class="br0">{</span>
  point<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  point<span class="br0">(</span><span class="kw4">int</span> x, <span class="kw4">int</span> y<span class="br0">)</span><span class="sy4">:</span> x_<span class="br0">(</span>x<span class="br0">)</span>, y_<span class="br0">(</span>y<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw4">int</span> x_, y_<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">union</span>
<span class="br0">{</span>
  <span class="kw4">int</span> z<span class="sy4">;</span>
  <span class="kw4">double</span> w<span class="sy4">;</span>
  point p<span class="sy4">;</span>  <span class="co1">// 不合法的 C++; point 有一 non-trivial 建構式</span>
            <span class="co1">// 合法的 C++11</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>这一改变仅放宽 union 的使用限制，不会影响既有的旧代码。</p>
<h2><span class="mw-headline" id=".E6.A0.B8.E5.BF.83.E8.AA.9E.E8.A8.80.E8.83.BD.E5.8A.9B.E7.9A.84.E6.8F.90.E5.8D.87">核心语言能力的提升</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=24" title="编辑段落：核心语言能力的提升">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>这些机能提供了C++语言能够做一些事情是以前所不能达成的，或是在以前需要繁琐的写法、要求一些不可移植的程序库。</p>
<h3><span class="mw-headline" id="-.7BA.7Czh-hans:.E5.8F.98.E9.95.BF.E5.8F.82.E6.95.B0.E6.A8.A1.E6.9D.BF.3B_zh-hant:.E4.B8.8D.E5.AE.9A.E9.95.B7.E5.8F.83.E6.95.B8.E6.A8.A1.E6.9D.BF.7D-">变长参数模板</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=25" title="编辑段落：变长参数模板">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在 C++11 之前, 不论是类模板或是函数模板，都只能按其被声明时所指定的样子，接受一组固定数目的模板参数 ； C++11 加入新的表示法，允许任意个数、任意类别的模板参数，不必在定义时将参数的个数固定。</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">typename</span>... <span class="me1">Values</span><span class="sy1">&gt;</span> <span class="kw2">class</span> tuple<span class="sy4">;</span>
</pre></div>
</div>
<p>模板类 <tt>tuple</tt> 的对象，能接受不限个数的 typename 作为它的模板形参：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">class</span> tuple<span class="sy1">&lt;</span><span class="kw4">int</span>, std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span>, std<span class="sy4">::</span><span class="me2">map</span><span class="sy1">&lt;</span>std<span class="sy4">::</span><span class="me2">string</span>, std<span class="sy4">::</span><span class="me2">vector</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;&gt;&gt;</span> someInstanceName<span class="sy4">;</span>
</pre></div>
</div>
<p>实参的个数也可以是 0，所以 <tt>class tuple&lt;&gt; someInstanceName</tt> 这样的定义也是可以的。</p>
<p>若不希望产生实参个数为 0 的变长参数模板，则可以采用以下的定义：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">typename</span> First, <span class="kw2">typename</span>... <span class="me1">Rest</span><span class="sy1">&gt;</span> <span class="kw2">class</span> tuple<span class="sy4">;</span>
</pre></div>
</div>
<p>变长参数模板也能运用到模板函数上。 传统 C 中的 printf 函数，虽然也能达成不定个数的形参的调用，但其并非类别安全。 
以下的样例中，C++11 除了能定义类别安全的变长参数函数外，还能让类似 printf 的函数能自然地处理非内置类别的对象。 
除了在模板参数中能使用<i>...</i>表示不定长模板参数外，函数参数也使用同样的表示法代表不定长参数。</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">typename</span>... <span class="me1">Params</span><span class="sy1">&gt;</span> <span class="kw4">void</span> <span class="kw3">printf</span><span class="br0">(</span><span class="kw4">const</span> std<span class="sy4">::</span><span class="me2">string</span> <span class="sy3">&amp;</span>strFormat, Params... <span class="me1">parameters</span><span class="br0">)</span><span class="sy4">;</span>
</pre></div>
</div>
<p>其中，<tt>Params</tt> 与 <tt>parameters</tt> 分别代表模板与函数的变长参数集合， 称之为参数包 (parameter pack)。参数包必须要和运算符"..."搭配使用，避免语法上的歧义。</p>
<p>变长参数模板中，变长参数包无法如同一般参数在类或函数中使用； 因此典型的手法是以递归的方法取出可用参数，参看以下的 C++11 <tt>printf</tt> 样例：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">void</span> <span class="kw3">printf</span><span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy2">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">while</span> <span class="br0">(</span><span class="sy2">*</span>s<span class="br0">)</span>
  <span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span><span class="sy2">*</span>s <span class="sy1">==</span> <span class="st0">'%'</span> <span class="sy3">&amp;&amp;</span> <span class="sy2">*</span><span class="br0">(</span><span class="sy2">++</span>s<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="st0">'%'</span><span class="br0">)</span>
      <span class="kw1">throw</span> std<span class="sy4">::</span><span class="me2">runtime_error</span><span class="br0">(</span><span class="st0">"invalid format string: missing arguments"</span><span class="br0">)</span><span class="sy4">;</span>
    std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="sy2">*</span>s<span class="sy2">++</span><span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">typename</span> T, <span class="kw2">typename</span>... <span class="me1">Args</span><span class="sy1">&gt;</span>
<span class="kw4">void</span> <span class="kw3">printf</span><span class="br0">(</span><span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> s, T value, Args... <span class="me1">args</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">while</span> <span class="br0">(</span><span class="sy2">*</span>s<span class="br0">)</span>
  <span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span><span class="sy2">*</span>s <span class="sy1">==</span> <span class="st0">'%'</span> <span class="sy3">&amp;&amp;</span> <span class="sy2">*</span><span class="br0">(</span><span class="sy2">++</span>s<span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="st0">'%'</span><span class="br0">)</span>
    <span class="br0">{</span>
      std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> value<span class="sy4">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="sy2">*</span>s <span class="sy4">?</span> <span class="sy2">++</span>s <span class="sy4">:</span> s, args...<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 即便当 *s == 0 也会产生调用，以检测更多的类型参数。</span>
      <span class="kw1">return</span><span class="sy4">;</span>
    <span class="br0">}</span>
    std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="sy2">*</span>s<span class="sy2">++</span><span class="sy4">;</span>
  <span class="br0">}</span>
  <span class="kw1">throw</span> std<span class="sy4">::</span><span class="me2">logic_error</span><span class="br0">(</span><span class="st0">"extra arguments provided to printf"</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>printf 会不断地递归调用自身：函数参数包 <tt>args...</tt> 在调用时， 会被模板类别匹配分离为 <tt>T value</tt>和 <tt>Args... args</tt>。 直到 <tt>args...</tt> 变为空参数，则会与简单的 <tt>printf(const char *s)</tt> 形成匹配，退出递归。</p>
<p>另一个例子为计算模板参数的个数，这里使用相似的技巧展开模板参数包 <tt>Args...</tt>：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">typename</span>... <span class="me1">args</span><span class="sy1">&gt;</span>
<span class="kw4">struct</span> Count<span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
<span class="kw2">template</span><span class="sy1">&lt;&gt;</span>
<span class="kw4">struct</span> count<span class="sy1">&lt;&gt;</span> <span class="br0">{</span>
    <span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">int</span> value <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">typename</span> T, <span class="kw2">typename</span>... <span class="me1">Args</span><span class="sy1">&gt;</span>
<span class="kw4">struct</span> count<span class="sy1">&lt;</span>T, Args...<span class="sy1">&gt;</span> <span class="br0">{</span> 
    <span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">int</span> value <span class="sy1">=</span> <span class="nu0">1</span> <span class="sy2">+</span> count<span class="sy1">&lt;</span>Args...<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>虽然没有一个简洁的机制能够对<a href="http://zh.wikipedia.org/w/index.php?title=%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF&amp;action=edit&amp;redlink=1" class="new" title="变长参数模板（页面不存在）">变长参数模板</a>中的值进行迭代，但使用运算符"..."还能在代码各处对参数包施以更复杂的展开操作。举例来说，一个模板类的定义：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span> <span class="sy1">&lt;</span><span class="kw2">typename</span>... <span class="me1">BaseClasses</span><span class="sy1">&gt;</span> <span class="kw2">class</span> ClassName <span class="sy4">:</span> <span class="kw2">public</span> BaseClasses...
<span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
 
   ClassName <span class="br0">(</span>BaseClasses<span class="sy3">&amp;&amp;</span>... <span class="me1">baseClasses</span><span class="br0">)</span> <span class="sy4">:</span> BaseClasses<span class="br0">(</span>baseClasses<span class="br0">)</span>... <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
</div>
<p><tt>BaseClasses...</tt> 会被展开成类型 <tt>ClassName</tt> 的基底类； ClassName 的构造函数需要所有基类的右值引用，而每一个基类都是以传入的参数做初始化 (<tt>BaseClasses(baseClasses)...</tt>)。</p>
<p>在函数模板中，变长参数可以和右值引用搭配，达成形参的完美转送 (perfect forwarding)：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">typename</span> TypeToConstruct<span class="sy1">&gt;</span> <span class="kw4">struct</span> SharedPtrAllocator
<span class="br0">{</span>
  <span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">typename</span>... <span class="me1">Args</span><span class="sy1">&gt;</span> std<span class="sy4">::</span><span class="me2">shared_ptr</span><span class="sy1">&lt;</span>TypeToConstruct<span class="sy1">&gt;</span> ConstructWithSharedPtr<span class="br0">(</span>Args<span class="sy3">&amp;&amp;</span>... <span class="me1">params</span><span class="br0">)</span>
  <span class="br0">{</span>
    <span class="kw1">return</span> tr1<span class="sy4">::</span><span class="me2">shared_ptr</span><span class="sy1">&lt;</span>TypeToConstruct<span class="sy1">&gt;</span><span class="br0">(</span><span class="kw3">new</span> TypeToConstruct<span class="br0">(</span>std<span class="sy4">::</span><span class="me2">forward</span><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span><span class="br0">(</span>params<span class="br0">)</span>...<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>参数包 <tt>parms</tt> 可展开为 <tt>TypeToConstruct</tt> 构造函数的形参。 表达式<tt>std::forward&lt;Args&gt;(params)</tt> 可将形参的类别信息保留(利用右值引用)，传入构造函数。 而运算符"..."则能将前述的表达式套用到每一个参数包中的参数。这种工厂函数(factory function)的手法， 使用 <tt>std::shared_ptr</tt> 管理配置对象的内存，避免了不当使用所产生的内存泄漏(memory leaks)。</p>
<p>此外，变长参数的数量可以藉以下的语法得知：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">typename</span> ...<span class="me1">Args</span><span class="sy1">&gt;</span> <span class="kw4">struct</span> SomeStruct
<span class="br0">{</span>
  <span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">int</span> size <span class="sy1">=</span> <span class="kw3">sizeof</span>...<span class="br0">(</span>Args<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
</pre></div>
</div>
<p><tt>SomeStruct&lt;Type1, Type2&gt;::size</tt> 是 2，而 <tt>SomeStruct&lt;&gt;::size</tt> 会是 0。 (<tt>sizeof...(Args)</tt> 的结果是编译期常数。)</p>
<h3><span class="mw-headline" id=".E6.96.B0.E7.9A.84.E5.AD.97.E4.B8.B2.E5.AD.97.E9.9D.A2.E5.80.BC">新的字符串字面值</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=26" title="编辑段落：新的字符串字面值">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>标准C++提供了两种字符串字面值。第一种，包含有双引号，产生以空字符结尾的<tt>const char</tt>数组。第二种有着前标L，产生以空字符结尾的<tt>const wchar_t</tt>数组，其中<tt>wchar_t</tt>代表宽字符。对于<a href="http://zh.wikipedia.org/wiki/Unicode" title="Unicode">Unicode</a>编码的支持尚付阙如。</p>
<p>为了加强C++编译器对Unicode的支持，类别<tt>char</tt>的定义被修改为其大小至少能够存储<a href="http://zh.wikipedia.org/wiki/UTF-8" title="UTF-8">UTF-8</a>的8位编码，并且能够容纳编译器的基本字符集的任何成员。</p>
<p>C++11 将支持三种Unicode编码方式：<a href="http://zh.wikipedia.org/wiki/UTF-8" title="UTF-8">UTF-8</a>，<a href="http://zh.wikipedia.org/wiki/UTF-16" title="UTF-16">UTF-16</a>，和<a href="http://zh.wikipedia.org/wiki/UTF-32" title="UTF-32">UTF-32</a>。除了上述<tt>char</tt>定义的变更， C++11将增加两种新的字符类别：<tt>char16_t</tt>和<tt>char32_t</tt>。它们各自被设计用来存储UTF-16 以及UTF-32的字符。</p>
<p>以下展示如何产生使用这些编码的字符串字面值：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">u8<span class="st0">"I'm a UTF-8 string."</span>
u<span class="st0">"This is a UTF-16 string."</span>
U<span class="st0">"This is a UTF-32 string."</span>
</pre></div>
</div>
<p>第一个字符串的类别是通常的<code>const char[]</code>；第二个字符串的类别是<code>const char16_t[]</code>；第三个字符串的类别是<code>const char32_t[]</code>。</p>
<p>当创建Unicode字符串字面值时，可以直接在字符串内插入Unicode codepoints。C++11提供了以下的语法：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">u8<span class="st0">"This is a Unicode Character: <span class="es3">\u2018</span>."</span>
u<span class="st0">"This is a bigger Unicode Character: <span class="es3">\u2018</span>."</span>
U<span class="st0">"This is a Unicode Character: <span class="es3">\u2018</span>."</span>
</pre></div>
</div>
<p>在'\u'之后的是16个比特的十六进制数值；它不需要'0x'的前标。识别字'\u'代表了一个16位的Unicode 
codepoint；如果要输入32位的codepoint，使用'\U'和32个比特的十六进制数值。只有有效的Unicode 
codepoints能够被输入。举例而言，codepoints在范围U+D800—U+DFFF之间是被禁止的，它们被保留给UTF-16编码的
surrogate pairs。</p>
<p>有时候避免手动将字符串换码也是很有用的，特别是在使用<a href="http://zh.wikipedia.org/wiki/XML" title="XML">XML</a>文件或是一些<a href="http://zh.wikipedia.org/wiki/%E8%85%B3%E6%9C%AC%E8%AA%9E%E8%A8%80" title="脚本语言" class="mw-redirect">脚本语言</a>的字面值的时候。 C++11将提供raw(未加工的)字符串字面值：</p>
<pre>R"(The String Data \ Stuff " )"
R"delimiter(The String Data \ Stuff " )delimiter"
</pre>
<p>在第一个例子中，任何包含在<code>(</code>&nbsp;<code>)</code>括号(标准已经从<code>[]</code>改为<code>()</code>)当中的都是字符串的一部分。其中<code>"</code>和<code>\</code>字符不需要经过转义(escaped)。在第二个例子中，<code>"delimiter(</code>开始字符串，只有在遇到<code>)delimiter"</code>才代表退出。其中<code>delimiter</code>可以是任意的字符串，能够允许用户在未加工的字符串字面值中使用<code>)</code>字符。 未加工的字符串字面值能够和宽字面值或是Unicode字面值结合：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">u8R<span class="st0">"XXX(I'm a "</span>raw UTF<span class="sy2">-</span><span class="nu0">8</span><span class="st0">" string.)XXX"</span>
uR<span class="st0">"*@(This is a "</span>raw UTF<span class="sy2">-</span><span class="nu0">16</span><span class="st0">" string.)*@"</span>
UR<span class="st0">"(This is a "</span>raw UTF<span class="sy2">-</span><span class="nu0">32</span><span class="st0">" string.)"</span>
</pre></div>
</div>
<h3><span class="mw-headline" id=".E4.BD.BF.E7.94.A8.E8.80.85.E8.87.AA.E8.A8.82.E7.9A.84.E5.AD.97.E9.9D.A2.E5.80.BC">用户自定义的字面值</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=27" title="编辑段落：用户自定义的字面值">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>标准C++提供了数种字面值。字符"12.5"是能够被编译器解释为数值12.5的<tt>double</tt>类别字面值。然而，加上"f"的后置，像是"12.5f"，则会产生数值为12.5的<tt>float</tt>类别字面值。在C++规范中字面值的后置是固定的，而且C++代码并不允许创立新的字面后置。</p>
<p>C++11 开放用户定义新的字面修饰符(literal modifier)，利用自定义的修饰符完成由字面值构造对象。</p>
<p>字面值转换可以区分为两个阶段：转换前与转换后 (raw 与 cooked)。 转换前的字面值指特定字符串行，而转换后的字面值则代表另一种类别。 如字面值<tt>1234</tt>，转换前的字面值代表 <tt>'1', '2', '3', '4'</tt> 的字符串行； 而转换后，字面值代表整数值<tt>1234</tt>。 另外，字面值<tt>0xA</tt>转换前是串行<tt>'0', 'x', 'A'</tt>；转换后代表整数值 10。</p>
<h3><span class="mw-headline" id=".E5.A4.9A.E5.B7.A5.E8.A8.98.E6.86.B6.E9.AB.94.E6.A8.A1.E5.9E.8B">多任务内存模型</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=28" title="编辑段落：多任务内存模型">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="rellink boilerplate seealso noprint">参见：<a href="http://zh.wikipedia.org/w/index.php?title=%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%28computing%29&amp;action=edit&amp;redlink=1" class="new" title="内存模型(computing)（页面不存在）">内存模型(computing)</a></div>
<p>C++标准委员会计划统一对<a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B" title="多线程">多线程编程</a>的支持。</p>
<p>这将涉及两个部分：第一、设计一个可以使多个线程在一个进程中共存的内存模型；第二、为线程之间的交互提供支持。第二部分将由程序库提供支持，更多请看<a href="#.E7.B7.92.E7.A8.8B.E6.94.AF.E6.8F.B4">线程支持</a>。</p>
<p>在多个线程可能会访问相同内存的情形下，由一个内存模型对它们进行调度是非常有必要的。遵守模型规则的程序是被保证正确运行的，但违反规则的程序会发生不可预料的行为，这些行为依赖于<a href="http://zh.wikipedia.org/w/index.php?title=%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%8C%96&amp;action=edit&amp;redlink=1" class="new" title="编译器的优化（页面不存在）">编译器的优化</a>和内存一致性的问题。</p>
<h3><span class="mw-headline" id="thread-local.E7.9A.84.E5.AD.98.E5.84.B2.E6.9C.9F.E9.99.90">thread-local的存储期限</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=29" title="编辑段落：thread-local的存储期限">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在多线程环境下，让各线程拥有各自的参数是很普遍的。这已经存在于函数的区域参数，但是对于全局和静态参数都还不行。</p>
<p>新的<i>thread_local</i>存储期限(在现行的<i>static</i>、<i>dynamic</i>和<i>automatic</i>之外)被作为下个标准而提出。线程区域的存储期限会借由存储指定字<code>thread_local</code>来表明。</p>
<p>static对象(生命周期为整个程序的运行期间)的存储期限可以被thread-local给替代。就如同其他使用static存储期的参数，thread-local对象能够以构造函数初始化并以析构函数摧毁。</p>
<h3><span class="mw-headline" id=".E4.BD.BF.E7.94.A8.E6.88.96.E7.A6.81.E7.94.A8.E7.89.A9.E4.BB.B6.E7.9A.84.E9.A0.90.E8.A8.AD.E5.87.BD.E5.BC.8F">使用或禁用对象的默认函数</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=30" title="编辑段落：使用或禁用对象的默认函数">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在传统C++中，若用户没有提供， 则编译器会自动为对象生成默认构造函数(default constructor)、 复制构造函数(copy constructor)，赋值运算符(copy assignment operator <tt>operator=</tt>) 以及析构函数(destructor)。另外，C++也为所有的类定义了数个全局运算符(如<tt>operator delete</tt>及<tt>operator new</tt>)。当用户有需要时，也可以提供自定义的版本改写上述的函数。</p>
<p>问题在于原先的c++无法精确地控制这些默认函数的生成。 比方说，要让类型不能被拷贝，必须将复制构造函数与赋值运算符声明为private，并不去定义它们。 尝试使用这些未定义的函数会导致编译期或链接期的错误。 但这种手法并不是一个理想的解决方案。</p>
<p>此外，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器便不会生成默认构造函数； 但有时同时带有上述两者提供的构造函数也是很有用的。 目前并没有显式指定编译器产生默认构造函数的方法。</p>
<p>C++11 允许显式地表明采用或拒用编译器提供的内置函数。例如要求类型带有默认构造函数，可以用以下的语法：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> SomeType
<span class="br0">{</span>
  SomeType<span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span> <span class="co1">// 預設建構式的顯式聲明</span>
  SomeType<span class="br0">(</span>OtherType value<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>另一方面，也可以禁止编译器自动产生某些函数。如下面的例子，类型不可复制：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> NonCopyable
<span class="br0">{</span>
  NonCopyable <span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span><span class="kw4">const</span> NonCopyable<span class="sy3">&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw3">delete</span><span class="sy4">;</span>
  NonCopyable<span class="br0">(</span><span class="kw4">const</span> NonCopyable<span class="sy3">&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw3">delete</span><span class="sy4">;</span>
  NonCopyable<span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>禁止类型以<tt>operator new</tt>配置内存：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> NonNewable
<span class="br0">{</span>
  <span class="kw4">void</span> <span class="sy2">*</span>operator <span class="kw3">new</span><span class="br0">(</span>std<span class="sy4">::</span><span class="kw4">size_t</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw3">delete</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>此种对象只能生成于 stack 中或是当作其他类型的成员，它无法直接配置于 heap 之中，除非使用了与平台相关，不可移植的手法。 (使用
 placement new 运算符虽然可以在用户自配置的内存上调用对象构造函数，但在此例中其他形式的 new 运算符一并被上述的定义 
屏蔽("name hiding")，所以也不可行。)</p>
<p><code>= delete</code>的声明(同时也是定义)也能适用于非内置函数， 禁止成员函数以特定的形参调用：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> NoDouble
<span class="br0">{</span>
  <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span> i<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw3">delete</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>若尝试以 double 的形参调用 <code>f()</code>，将会引发编译期错误， 编译器不会自动将 double 形参转型为 int 再调用<code>f()</code>。 若要彻底的禁止以非int的形参调用<code>f()</code>，可以将<code>= delete</code>与模板相结合：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> OnlyInt
<span class="br0">{</span>
  <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span> i<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span> <span class="sy1">=</span> <span class="kw3">delete</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<h3><span class="mw-headline" id="long_long_int.E5.9E.8B.E5.88.A5"><code>long long int</code>类别</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=31" title="编辑段落：long long int类别">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在 32 比特系统上，一个 <code>long long int</code> 是保有至少 64 个有效比特的整数类别。<a href="http://zh.wikipedia.org/wiki/C99" title="C99" class="mw-redirect">C99</a> 将这个类别引入了标准 C 中，目前大多数的 C++ 编译器也支持这种类别。C++11 将把这种类别添加到标准 C++ 中。</p>
<h3><span class="mw-headline" id=".E9.9D.9C.E6.85.8Bassertion">静态assertion</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=32" title="编辑段落：静态assertion">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>C++提供了两种方法测试assertion(声明)：宏<code>assert</code>以及<a href="http://zh.wikipedia.org/w/index.php?title=%E5%89%8D%E8%99%95%E7%90%86%E5%99%A8&amp;action=edit&amp;redlink=1" class="new" title="预处理器（页面不存在）">预处理器</a>指令<code>#error</code>。但是这两者对于模版来说都不合用。宏在运行期测试assertion，而预处理器指令则在前置处理时测试assertion，这时候模版还未能实例化。所以它们都不适合来测试牵扯到模板参数的相关特性。</p>
<p>新的机能会引进新的方式可以在编译期测试assertion，只要使用新的关键字<code>static_assert</code>。 声明采取以下的形式：</p>
<pre>static_assert( <i>constant-expression</i>, <i>error-message</i> ) ;
</pre>
<p>这里有一些如何使用<code>static_assert</code>的例子：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">static_assert<span class="br0">(</span> <span class="nu16">3.14</span> <span class="sy1">&lt;</span> GREEKPI <span class="sy3">&amp;&amp;</span> GREEKPI <span class="sy1">&lt;</span> <span class="nu16">3.15</span>, <span class="st0">"GREEKPI is inaccurate!"</span> <span class="br0">)</span> <span class="sy4">;</span>
</pre></div>
</div>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span> <span class="kw2">class</span> T <span class="sy1">&gt;</span>
<span class="kw4">struct</span> Check
<span class="br0">{</span>
  static_assert<span class="br0">(</span> <span class="kw3">sizeof</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">&lt;=</span> <span class="kw3">sizeof</span><span class="br0">(</span>T<span class="br0">)</span>, <span class="st0">"T is not big enough!"</span> <span class="br0">)</span> <span class="sy4">;</span>
<span class="br0">}</span> <span class="sy4">;</span>
</pre></div>
</div>
<p>当常数表达式值为<code>false</code>时，编译器会产生相应的错误信息。第一个例子是预处理器指令<code>#error</code>的替代方案；第二个例子会在每个模板类型<code>Check</code>生成时检查assertion。</p>
<p>静态assertion在模板之外也是相当有用的。例如，某个算法的实现依赖于<code>long long</code>类别的大小比<code>int</code>还大，这是标准所不保证的。 这种假设在大多数的系统以及编译器上是有效的，但不是全部。</p>
<h3><span class="mw-headline" id=".E5.85.81.E8.A8.B1sizeof.E9.81.8B.E7.AE.97.E5.AD.90.E4.BD.9C.E7.94.A8.E5.9C.A8.E9.A1.9E.E5.88.A5.E7.9A.84.E8.B3.87.E6.96.99.E6.88.90.E5.93.A1.E4.B8.8A.EF.BC.8C.E7.84.A1.E9.A0.88.E6.98.8E.E7.A2.BA.E7.9A.84.E7.89.A9.E4.BB.B6">允许sizeof运算符作用在类型的数据成员上，无须明确的对象</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=33" title="编辑段落：允许sizeof运算符作用在类型的数据成员上，无须明确的对象">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在标准C++，<tt>sizeof</tt>可以作用在对象以及类别上。但是不能够做以下的事：</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> SomeType <span class="br0">{</span> OtherType member<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw3">sizeof</span><span class="br0">(</span>SomeType<span class="sy4">::</span><span class="me2">member</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 直接由SomeType型別取得非靜態成員的大小，C++03不行。 C++11允許</span>
</pre></div>
</div>
<p>这会传回<tt>OtherType</tt>的大小。C++03并不允许这样做，所以会引发编译错误。C++11将会允许这种使用。</p>
<h3><span class="mw-headline" id=".E5.9E.83.E5.9C.BE.E5.9B.9E.E6.94.B6.E6.A9.9F.E5.88.B6">垃圾回收机制</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=34" title="编辑段落：垃圾回收机制">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>是否会自动回收那些无法被使用到 (unreachable) 的动态分配对象由实现决定。</p>
<h2><span class="mw-headline" id="C.2B.2B.E6.A8.99.E6.BA.96.E7.A8.8B.E5.BC.8F.E5.BA.AB.E7.9A.84.E8.AE.8A.E6.9B.B4">C++标准程序库的变更</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=35" title="编辑段落：C++标准程序库的变更">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>C++11 标准<a href="http://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E5%BA%AB" title="程序库" class="mw-redirect">程序库</a>有数个新机能。其中许多可以在现行标准下实现，而另外一些则依赖于(或多或少)新的 C++11 核心语言机能。</p>
<p>新的程序库的大部分被定义于<i><a href="http://zh.wikipedia.org/wiki/TR1" title="TR1" class="mw-redirect">C++标准委员会的Library Technical Report</a></i> (称TR1)，于2005年发布。各式 TR1 的完全或部分实现目前提供在<a href="http://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" title="命名空间">命名空间</a> <code>std::tr1</code>。C++11 会将其移置于命名空间 <code>std</code> 之下。</p>
<h3><span class="mw-headline" id=".E6.A8.99.E6.BA.96.E5.BA.AB.E5.85.83.E4.BB.B6.E4.B8.8A.E7.9A.84.E5.8D.87.E7.B4.9A">标准库组件上的升级</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=36" title="编辑段落：标准库组件上的升级">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>目前的标准库能受益于 C++11 新增的一些语言特性。举例来说，对于大部份的标准库容器而言，像是搬移内含大量元素的容器，或是容器之内对元素的搬移，基于右值引用 (Rvalue reference) 的 <code>move</code> 构造函数都能优化前述动作。在适当的情况下，标准库组件将可利用 C++11 的语言特性进行升级。这些语言特性包含但不局限以下所列:</p>
<ul>
<li>右值引用和其相关的 <code>move</code> 支持</li>
<li>支持 UTF-16 编码，和 UTF-32 字符集</li>
<li>变长参数模板 (与右值引用搭配可以达成完美转送 (perfect forwarding))</li>
<li>编译期常数表达式</li>
<li><code>Decltype</code></li>
<li>显式类别转换子</li>
<li>使用或禁用对象的默认函数</li>
</ul>
<p>此外，自 C++ 标准化之后已经过许多年。现有许多代码利用到了标准库; 这同时揭露了部份的标准库可以做些改良。其中之一是标准库的内存配置器 (allocator)。C++11将会加入一个基于作用域模型的内存配置器来支持现有的模型。</p>
<h3><span class="mw-headline" id=".E5.9F.B7.E8.A1.8C.E7.B7.92.E6.94.AF.E6.8F.B4">线程支持</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=37" title="编辑段落：线程支持">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>虽然 C++11 会在语言的定义上提供一个内存模型以支持线程，但线程的使用主要将以 C++11 标准库的方式呈现。</p>
<p>C++11 标准库会提供类型 <code>thread</code> (<code>std::thread</code>)。若要运行一个线程，可以创建一个类型 <code>thread</code> 的实体，其初始参数为一个函数对象，以及该函数对象所需要的参数。通过成员函数 <code>std::thread::join()</code> 对线程会合的支持，一个线程可以暂停直到其它线程运行完毕。若有底层平台支持，成员函数 <code>std::thread::native_handle()</code> 将可提供对原生线程对象运行平台特定的操作。</p>
<p>对于线程间的同步，标准库将会提供适当的互斥锁 (像是 <code>std::mutex</code>，<code>std::recursive_mutex</code> 等等) 和条件参数 (<code>std::condition_variable</code> 和 <code>std::condition_variable_any</code>)。前述同步机制将会以 RAII 锁 (<code>std::lock_guard</code> 和 <code>std::unique_lock</code>) 和锁相关算法的方式呈现，以方便程序员使用。</p>
<p>对于要求高性能，或是极底层的工作，有时或甚至是必须的，我们希望线程间的通信能避免互斥锁使用上的开销。以原子操作来访问内存可以达成此目的。针对不同情况，我们可以通过显性的内存屏障改变该访问内存动作的可见性。</p>
<p>对于线程间异步的传输，C++11 标准库加入了 以及 <code>std::packaged_task</code> 用来包装一个会传回异步结果的函数调用。 因为缺少结合数个 future 的功能，和无法判定一组 promise 集合中的某一个 promise 是否完成，futures 此一提案因此而受到了批评。</p>
<p>更高级的线程支持，如线程池，已经决定留待在未来的 Technical Report 加入此类支持。更高级的线程支持不会是 C++11 的一部份，但设想是其最终实现将创建在目前已有的线程支持之上。</p>
<p><code>std::async</code> 提供了一个简便方法以用来运行线程，并将线程绑定在 <code>std::future</code>。用户可以选择一个工作是要多个线程上异步的运行，或是在一个线程上运行并等待其所需要的数据。默认的情况，实现可以根据底层硬件选择前面两个选项的其中之一。另外在较简单的使用情形下，实现也可以利用线程池提供支持。</p>
<h3><span class="mw-headline" id=".E5.A4.9A.E5.85.83.E7.B5.84.E5.9E.8B.E5.88.A5">多元组类别</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=38" title="编辑段落：多元组类别">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E5%85%83%E7%BB%84" title="多元组">多元组</a>是一个内由数个异质对象以特定顺序排列而成的数据结构。多元组可被视为是 <code>struct</code> 其数据成员的一般化。</p>
<p>由 TR1 演进而来的 C++11 多元组类别将受益于 C++11 某些特色像是<a href="#.E4.B8.8D.E5.AE.9A.E9.95.B7.E5.8F.83.E6.95.B8.E6.A8.A1.E6.9D.BF">变长参数模板</a>。TR1
 版本的多元组类别对所能容纳的对象个数会因实现而有所限制，且实现上需要用到大量的宏技巧。相反的，C++11 
版本的多元组型基本上于对其能容纳的对象个数没有限制。然而，编译器对于模板实体化的递归深度上的限制仍旧影响了元组类别所能容纳的对象个数 
(这是无法避免的情况); C++11 版本的多元组型不会把这个值让用户知道。</p>
<p>使用<a href="#.E4.B8.8D.E5.AE.9A.E9.95.B7.E5.8F.83.E6.95.B8.E6.A8.A1.E6.9D.BF">变长参数模板</a>，多元组类别的声明可以长得像下面这样:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span> <span class="sy1">&lt;</span><span class="kw2">class</span> ...<span class="me1">Types</span><span class="sy1">&gt;</span> <span class="kw2">class</span> tuple<span class="sy4">;</span>
</pre></div>
</div>
<p>底下是一个多元组类别的定义和使用情况:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">typedef</span> std<span class="sy4">::</span><span class="me2">tuple</span> <span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">double</span>, <span class="kw4">long</span> <span class="sy3">&amp;</span>, <span class="kw4">const</span> <span class="kw4">char</span> <span class="sy2">*</span><span class="sy1">&gt;</span> test_tuple<span class="sy4">;</span>
<span class="kw4">long</span> lengthy <span class="sy1">=</span> <span class="nu0">12</span><span class="sy4">;</span>
test_tuple proof <span class="br0">(</span><span class="nu0">18</span>, <span class="nu16">6.5</span>, lengthy, <span class="st0">"Ciao!"</span><span class="br0">)</span><span class="sy4">;</span>
 
lengthy <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">get</span><span class="sy1">&lt;</span><span class="nu0">0</span><span class="sy1">&gt;</span><span class="br0">(</span>proof<span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// 將 proof 的第一個元素賦值給 lengthy (索引從零開始起跳)</span>
std<span class="sy4">::</span><span class="me2">get</span><span class="sy1">&lt;</span><span class="nu0">3</span><span class="sy1">&gt;</span><span class="br0">(</span>proof<span class="br0">)</span> <span class="sy1">=</span> <span class="st0">" Beautiful!"</span><span class="sy4">;</span>  <span class="co1">// 修改 proof 的第四個元素</span>
</pre></div>
</div>
<p>我们可以定义一个多元组类别对象 <code>proof</code> 而不指定其内容，前提是 <code>proof</code> 
里的元素其类别定义了默认构造函数 (default 
constructor)。此外，以一个多元组类别对象赋值给另一个多元组类别对象是可能的，但只有在以下情况: 
若这两个多元组类别相同，则其内含的每一个元素其类别都要定义拷贝构造函数 (copy constructor); 
否则的话，赋值操作符右边的多元组其内含元素的类别必须能转换成左边的多元组其对应的元素类别，又或者赋值操作符左边的多元组其内含元素的类别必须定义适
当的构造函数。</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">typedef</span> std<span class="sy4">::</span><span class="me2">tuple</span><span class="sy1">&lt;</span> <span class="kw4">int</span> , <span class="kw4">double</span>, string       <span class="sy1">&gt;</span> tuple_1 t1<span class="sy4">;</span>
<span class="kw4">typedef</span> std<span class="sy4">::</span><span class="me2">tuple</span><span class="sy1">&lt;</span> <span class="kw4">char</span>, <span class="kw4">short</span> , <span class="kw4">const</span> <span class="kw4">char</span> <span class="sy2">*</span> <span class="sy1">&gt;</span> tuple_2 t2 <span class="br0">(</span><span class="st0">'X'</span>, <span class="nu0">2</span>, <span class="st0">"Hola!"</span><span class="br0">)</span><span class="sy4">;</span>
t1 <span class="sy1">=</span> t2 <span class="sy4">;</span>  <span class="co1">// 可行。前兩個元素會作型別轉換，</span>
           <span class="co1">// 第三個字串元素可由 'const char *' 所建構。</span>
</pre></div>
</div>
<p>多元组类型对象的比较运算是可行的(当它们拥有同样数量的元素)。此外，C++11 提供两个表达式用来检查多元组类型的一些特性 (仅在编译期做此检查)。</p>
<ul>
<li><code>std::tuple_size&lt;T&gt;::value</code> 回传多元组 <code>T</code> 内的元素个数，</li>
<li><code>std::tuple_element&lt;I, T&gt;::type</code> 回传多元组 <code>T</code> 内的第 <code>I</code> 个元素的类别</li>
</ul>
<h3><span class="mw-headline" id=".E9.9B.9C.E6.B9.8A.E8.A1.A8">散列表</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=39" title="编辑段落：散列表">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>在过去，不断有要求想将散列表(无序关系式容器)引进标准库。只因为时间上的限制，散列表才没有被标准库所采纳。虽然，散列表在最糟情况下(如果出现许多冲突 (collision) 的话)在性能上比不过平衡树。但实际运用上，散列表的表现则较佳。</p>
<p>因为标准委员会还看不到有任何机会能将开放寻址法标准化，所以目前冲突仅能通过<a href="#.E5.93.88.E5.B8.8C.E8.A1.A8">链地址法 (linear chaining)</a> 的方式处理。为避免与第三方库发展的散列表发生名称上的冲突，前缀将采用 unordered 而非 hash。</p>
<p>库将引进四种散列表，其中差别在于底下两个特性: 是否接受具相同键值的项目 (Equivalent keys)，以及是否会将键值映射到相对应的数据 (Associated values)。</p>
<table class="wikitable" style="text-align: center">
<tbody><tr>
<th>散列表类型</th>
<th>有无关系值</th>
<th>接受相同键值</th>
</tr>
<tr>
<td style="text-align: left"><code>std::unordered_set</code></td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">否</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">否</td>
</tr>
<tr>
<td style="text-align: left"><code>std::unordered_multiset</code></td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">否</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">是</td>
</tr>
<tr>
<td style="text-align: left"><code>std::unordered_map</code></td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">是</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no">否</td>
</tr>
<tr>
<td style="text-align: left"><code>std::unordered_multimap</code></td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">是</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">是</td>
</tr>
</tbody></table>
<p>上述的类型将满足对一个容器类型的要求，同时也提供访问其中元素的成员函数: <code>insert</code>, <code>erase</code>, <code>begin</code>, <code>end</code>。</p>
<p>散列表不需要对现有核心语言做扩展(虽然散列表的实现会利用到 C++11 新的语言特性)，只会对头文件 <code>&lt;functional&gt;</code> 做些许扩展，并引入 <code>&lt;unordered_set&gt;</code> 和 <code>&lt;unordered_map&gt;</code> 两个头文件。对于其它现有的类型不会有任何修改。同时，散列表也不会依赖其它标准库的扩展功能。</p>
<h3><span class="mw-headline" id=".E6.AD.A3.E8.A6.8F.E8.A1.A8.E7.A4.BA.E5.BC.8F">正则表达式</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=40" title="编辑段落：正则表达式">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>过去许多或多或少标准化的程序库被创建用来处理<a href="http://zh.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E5%BC%8F" title="正则表达式" class="mw-redirect">正则表达式</a>。有鉴于这些算法的使用非常普遍，因此标准程序库将会包含他们，并使用各种<a href="http://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80" title="面向对象语言" class="mw-redirect">面向对象语言</a>的潜力。</p>
<p>这个新的程序库，被定义于<code>&lt;regex&gt;</code>头文件，由几个新的类型所组成:</p>
<ul>
<li>正则表达式(模式)以样板类 <code>basic_regex</code> 的实体表示</li>
<li>模式匹配的情况以样板类 <code>match_results</code> 的实体表示</li>
</ul>
<p>函数 <code>regex_search</code> 是用来搜索模式; 若要搜索并取代，则要使用函数 <code>regex_replace</code>，该函数会回传一个新的字符串。算法<code>regex_search</code> 和 <code>regex_replace</code> 接受一个正则表达式(模式)和一个字符串，并将该模式匹配的情况存储在 struct <code>match_results</code>。</p>
<p>底下描述了 <code>match_results</code> 的使用情况:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy2">*</span>reg_esp <span class="sy1">=</span> <span class="st0">"[ ,.<span class="es1">\\</span>t<span class="es1">\\</span>n;:]"</span> <span class="sy4">;</span>  <span class="co1">// 分隔字元列表</span>
 
std<span class="sy4">::</span><span class="me2">regex</span> rgx<span class="br0">(</span>reg_esp<span class="br0">)</span> <span class="sy4">;</span>  <span class="co1">// 'regex' 是樣板類 'basic_regex' 以型別為 'char' </span>
                           <span class="co1">//  的參數具現化的實體</span>
std<span class="sy4">::</span><span class="me2">cmatch</span> match <span class="sy4">;</span>  <span class="co1">// 'cmatch' 是樣板類 match_results' 以型別為 'const char *'</span>
                     <span class="co1">// '的參數具現化的實體</span>
<span class="kw4">const</span> <span class="kw4">char</span> <span class="sy2">*</span>target <span class="sy1">=</span> <span class="st0">"Polytechnic University of Turin "</span> <span class="sy4">;</span>
 
<span class="co1">// 辨別所有被分隔字元所分隔的字</span>
<span class="kw1">if</span><span class="br0">(</span> regex_search<span class="br0">(</span> target, match, rgx <span class="br0">)</span> <span class="br0">)</span>
<span class="br0">{</span>
  <span class="co1">// 若此種字存在</span>
 
  <span class="kw4">const</span> <span class="kw4">size_t</span> n <span class="sy1">=</span> match.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">for</span><span class="br0">(</span> <span class="kw4">size_t</span> a <span class="sy1">=</span> <span class="nu0">0</span> <span class="sy4">;</span> a <span class="sy1">&lt;</span> n <span class="sy4">;</span> a<span class="sy2">++</span> <span class="br0">)</span>
  <span class="br0">{</span>
    string str<span class="br0">(</span> match<span class="br0">[</span>a<span class="br0">]</span>.<span class="me1">first</span>, match<span class="br0">[</span>a<span class="br0">]</span>.<span class="me1">second</span> <span class="br0">)</span> <span class="sy4">;</span>
    <span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> str <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\n</span>"</span> <span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>注意双反斜线的使用，因为 C++ 将反斜线作为转义字符使用。但 C++11 的<a href="#.E6.96.B0.E7.9A.84.E5.AD.97.E4.B8.B2.E5.AD.97.E9.9D.A2.E5.80.BC">raw string</a>可以用来避免此一问题。库 &lt;regex&gt; 不需要改动到现有的头文件，同时也不需要对现有的语言作扩展。</p>
<h3><span class="mw-headline" id=".E9.80.9A.E7.94.A8.E6.99.BA.E8.83.BD.E6.8C.87.E9.87.9D">通用智能指针</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=41" title="编辑段落：通用智能指针">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>这些指针是由 TR1 智能指针演变而来。注意! 智能指针是类型而非一般指针。</p>
<p><code>shared_ptr</code> 是一引用计数 (reference-counted) 指针，其行为与一般 C++ 指针极为相似。在 TR1 的实现中，缺少了一些一般指针所拥有的特色，像是别名或是指针运算。C++11新增前述特色。</p>
<p>一个 <code>shared_ptr</code> 只有在已经没有任何其它 <code>shared_ptr</code> 指向其原本所指向对象时，才会销毁该对象。</p>
<p>一个 <code>weak_ptr</code> 指向的是一个被 <code>shared_ptr</code> 所指向的对象。该 <code>weak_ptr</code> 可以用来决定该对象是否已被销毁。<code>weak_ptr</code> 不能被解引用; 想要访问其内部所保存的指针，只能通过 <code>shared_ptr</code>。有两种方法可达成此目的。第一，类型 <code>shared_ptr</code> 有一个以 <code>weak_ptr</code> 为参数的构造函数。第二，类型 <code>weak_ptr</code> 有一个名为 <code>lock</code> 的成员函数，其回返值为一个 <code>shared_ptr</code>。<code>weak_ptr</code> 并不拥有它所指向的对象，因此不影响该对象的销毁与否。</p>
<p>底下是一个 <code>shared_ptr</code> 的使用样例:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">int</span> main<span class="br0">(</span> <span class="br0">)</span>
<span class="br0">{</span>
    std<span class="sy4">::</span><span class="me2">shared_ptr</span><span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span> p_first<span class="br0">(</span><span class="kw3">new</span> <span class="kw4">double</span><span class="br0">)</span> <span class="sy4">;</span>
 
    <span class="br0">{</span>
        std<span class="sy4">::</span><span class="me2">shared_ptr</span><span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span> p_copy <span class="sy1">=</span> p_first <span class="sy4">;</span>
 
        <span class="sy2">*</span>p_copy <span class="sy1">=</span> <span class="nu16">21.2</span><span class="sy4">;</span>
 
    <span class="br0">}</span>  <span class="co1">// 此時 'p_copy' 會被銷毀，但動態分配的 double 不會被銷毀。</span>
 
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>  <span class="co1">// 此時 'p_first' 會被銷毀，動態分配的 double 也會被銷毀 (因為不再有指針指向它)。</span>
<span class="br0">}</span>
</pre></div>
</div>
<p><code>auto_ptr</code> 将会被 C++ 标准所废弃，取而代之的是 <code>unique_ptr</code>。 <code>unique_ptr</code> 提供 <code>auto_ptr</code> 大部份特性，唯一的例外是 <code>auto_ptr</code> 的不安全、隐性的左值搬移。不像 <code>auto_ptr</code>，<code>unique_ptr</code> 可以存放在 C++11 提出的那些能察觉搬移动作的容器之中。</p>
<h3><span class="mw-headline" id=".E5.8F.AF.E6.89.A9.E5.B1.95.E7.9A.84.E9.9A.8F.E6.9C.BA.E6.95.B0.E5.8A.9F.E8.83.BD">可扩展的随机数功能</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=42" title="编辑段落：可扩展的随机数功能">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>C 标准库允许使用<code>rand</code>函数来生成<a href="http://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0" title="伪随机数" class="mw-redirect">伪随机数</a>。不过其算法则取决于各程序库开发者。 C++ 直接从 C 继承了这部份，但是 C++11 将会提供产生伪乱数的新方法。</p>
<p>C++11 的随机数功能分为两部分： 第一，一个乱数生成引擎，其中包含该生成引擎的状态，用来产生乱数。第二，一个分布，这可以用来决定产生乱数的范围，也可以决定以何种分布方式产生乱数。乱数生成对象即是由乱数生成引擎和分布所构成。</p>
<p>不同于 C 标准库的 <code>rand</code>; 针对产生乱数的机制，C++11 将会提供三种算法，每一种算法都有其强项和弱项:</p>
<table class="wikitable">
<tbody><tr>
<th>样板类</th>
<th>整数/浮点数</th>
<th>质量</th>
<th>速度</th>
<th>状态数*</th>
</tr>
<tr>
<th>linear_congruential</th>
<td align="center">整数</td>
<td align="center">低</td>
<td align="center">中等<sup class="noprint Template-Fact"><a href="http://zh.wikipedia.org/wiki/Wikipedia:%E5%88%97%E6%98%8E%E6%9D%A5%E6%BA%90" title="Wikipedia:列明来源"><span style="white-space: nowrap;" title="来源请求开始于2009年4月26日。">[来源请求]</span></a></sup></td>
<td align="center">1</td>
</tr>
<tr>
<th>subtract_with_carry</th>
<td align="center">两者皆可</td>
<td align="center">中等</td>
<td align="center">快</td>
<td align="center">25</td>
</tr>
<tr>
<th>mersenne_twister</th>
<td align="center">整数</td>
<td align="center">佳</td>
<td align="center">快</td>
<td align="center">624</td>
</tr>
</tbody></table>
<p>C++11 将会提供一些标准分布: uniform_int_distribution (<a href="http://zh.wikipedia.org/wiki/%E9%9B%A2%E6%95%A3%E5%9E%8B%E5%9D%87%E5%8B%BB%E5%88%86%E4%BD%88" title="离散型均匀分布">离散型均匀分布</a>)，bernoulli_distribution (<a href="http://zh.wikipedia.org/wiki/%E4%BC%AF%E5%8A%AA%E5%88%A9%E5%88%86%E5%B8%83" title="伯努利分布">伯努利分布</a>)，geometric_distribution (<a href="http://zh.wikipedia.org/wiki/%E5%B9%BE%E4%BD%95%E5%88%86%E4%BD%88" title="几何分布">几何分布</a>)， poisson_distribution (<a href="http://zh.wikipedia.org/wiki/%E5%8D%9C%E7%93%A6%E6%9D%BE%E5%88%86%E4%BD%88" title="卜瓦松分布" class="mw-redirect">卜瓦松分布</a>)，binomial_distribution (<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E5%88%86%E4%BD%88" title="二项分布">二项分布</a>)，uniform_real_distribution (<a href="http://zh.wikipedia.org/wiki/%E9%9B%A2%E6%95%A3%E5%9E%8B%E5%9D%87%E5%8B%BB%E5%88%86%E4%BD%88" title="离散型均匀分布">离散型均匀分布</a>)， exponential_distribution (<a href="http://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83" title="指数分布">指数分布</a>)，normal_distribution (<a href="http://zh.wikipedia.org/wiki/%E5%B8%B8%E6%85%8B%E5%88%86%E4%BD%88" title="正态分布" class="mw-redirect">正态分布</a>) 和 gamma_distribution (<a href="http://zh.wikipedia.org/wiki/%E4%BC%BD%E7%8E%9B%E5%88%86%E5%B8%83" title="伽玛分布">伽玛分布</a>)。</p>
<p>底下描述一个乱数生成对象如何由乱数生成引擎和分布构成:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">std<span class="sy4">::</span><span class="me2">uniform_int_distribution</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> distribution<span class="br0">(</span><span class="nu0">0</span>, <span class="nu0">99</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 以離散型均勻分佈方式產生 int 亂數，範圍落在 0 到 99 之間</span>
std<span class="sy4">::</span><span class="me2">mt19937</span> engine<span class="sy4">;</span> <span class="co1">// 建立亂數生成引擎</span>
<span class="kw4">auto</span> generator <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">bind</span><span class="br0">(</span>distribution, engine<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 利用 bind 將亂數生成引擎和分布組合成一個亂數生成物件</span>
<span class="kw4">int</span> random <span class="sy1">=</span> generator<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// 產生亂數</span>
</pre></div>
</div>
<h3><span class="mw-headline" id=".E5.8C.85.E8.A3.85.E5.BC.95.E7.94.A8">包装引用</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=43" title="编辑段落：包装引用">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>我们可以通过实体化样板类 <code>reference_wrapper</code> 得到一个包装引用 (wrapper reference)。包装引用类似于一般的引用。对于任意对象，我们可以通过模板类 <code>ref</code> 得到一个包装引用 (至于 constant reference 则可通过 <code>cref</code> 得到)。</p>
<p>当样板函数需要形参的引用而非其拷贝，这时包装引用就能派上用场:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="co1">// 此函數將得到形參 'r' 的引用並對 r 加一</span>
<span class="kw4">void</span> f <span class="br0">(</span><span class="kw4">int</span> <span class="sy3">&amp;</span>r<span class="br0">)</span>  <span class="br0">{</span> r<span class="sy2">++</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="co1">// 樣板函式</span>
<span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">class</span> F, <span class="kw2">class</span> P<span class="sy1">&gt;</span> <span class="kw4">void</span> g <span class="br0">(</span>F f, P t<span class="br0">)</span>  <span class="br0">{</span> f<span class="br0">(</span>t<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> i <span class="sy1">=</span> <span class="nu0">0</span> <span class="sy4">;</span>
    g <span class="br0">(</span>f, i<span class="br0">)</span> <span class="sy4">;</span>  <span class="co1">// 實體化 'g&lt;void (int &amp;r), int&gt;' </span>
                <span class="co1">// 'i' 不會被修改</span>
    std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> i <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>  <span class="co1">// 輸出 0</span>
 
    g <span class="br0">(</span>f, std<span class="sy4">::</span><span class="me2">ref</span><span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// 實體化 'g&lt;void(int &amp;r),reference_wrapper&lt;int&gt;&gt;'</span>
                         <span class="co1">// 'i' 會被修改</span>
    std<span class="sy4">::</span><span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> i <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>  <span class="co1">// 輸出 1</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>这项功能将加入头文件 <code>&lt;utility&gt;</code> 之中，而非通过扩展语言来得到这项功能。</p>
<h3><span class="mw-headline" id=".E5.A4.9A.E6.80.81.E5.87.BD.E6.95.B0.E5.AF.B9.E8.B1.A1.E5.8C.85.E8.A3.85.E5.99.A8">多态函数对象包装器</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=44" title="编辑段落：多态函数对象包装器">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>针对函数对象的多态包装器(又称多态函数对象包装器)在语义和语法上和函数指针相似，但不像函数指针那么狭隘。只要能被调用，且其参数能与包装器兼容的都能以多态函数对象包装器称之(函数指针，成员函数指针或仿函数)。</p>
<p>通过以下例子，我们可以了解多态函数对象包装器的特性:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1">std<span class="sy4">::</span><span class="me2">function</span><span class="sy1">&lt;</span><span class="kw4">int</span> <span class="br0">(</span><span class="kw4">int</span>, <span class="kw4">int</span><span class="br0">)</span><span class="sy1">&gt;</span> func<span class="sy4">;</span>  <span class="co1">// 利用樣板類 'function'</span>
                                     <span class="co1">// 建立包裝器</span>
std<span class="sy4">::</span><span class="me2">plus</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> add<span class="sy4">;</span>  <span class="co1">// 'plus' 被宣告為 'template&lt;class T&gt; T plus( T, T ) ;'</span>
                     <span class="co1">//  因此 'add' 的型別是 'int add( int x, int y )'</span>
func <span class="sy1">=</span> <span class="sy3">&amp;</span>add<span class="sy4">;</span>  <span class="co1">// 可行。'add' 的型參和回返值型別與 'func' 相符</span>
 
<span class="kw4">int</span> a <span class="sy1">=</span> func <span class="br0">(</span><span class="nu0">1</span>, <span class="nu0">2</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// 注意: 若包裝器 'func' 沒有參考到任何函式</span>
                      <span class="co1">// 會丟出 'std::bad_function_call' 例外</span>
 
std<span class="sy4">::</span><span class="me2">function</span><span class="sy1">&lt;</span><span class="kw4">bool</span> <span class="br0">(</span><span class="kw4">short</span>, <span class="kw4">short</span><span class="br0">)</span><span class="sy1">&gt;</span> func2 <span class="sy4">;</span>
<span class="kw1">if</span><span class="br0">(</span><span class="sy3">!</span>func2<span class="br0">)</span> <span class="br0">{</span> <span class="co1">// 因為尚未賦值與 'func2' 任何函式，此條件式為真</span>
 
    <span class="kw4">bool</span> adjacent<span class="br0">(</span><span class="kw4">long</span> x, <span class="kw4">long</span> y<span class="br0">)</span><span class="sy4">;</span>
    func2 <span class="sy1">=</span> <span class="sy3">&amp;</span>adjacent <span class="sy4">;</span>  <span class="co1">// 可行。'adjacent' 的型參和回返值型別可透過型別轉換進而與 'func2' 相符</span>
 
    <span class="kw4">struct</span> Test <span class="br0">{</span>
        <span class="kw4">bool</span> operator<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">short</span> x, <span class="kw4">short</span> y<span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span><span class="sy4">;</span>
    Test car<span class="sy4">;</span>
    func <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">ref</span><span class="br0">(</span>car<span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// 樣板類 'std::ref' 回傳一個 struct 'car'</span>
                           <span class="co1">// 其成員函式 'operator()' 的包裝</span>
<span class="br0">}</span>
func <span class="sy1">=</span> func2<span class="sy4">;</span>  <span class="co1">// 可行。'func2' 的型參和回返值型別可透過型別轉換進而與 'func' 相符</span>
</pre></div>
</div>
<p>模板类 <code>function</code> 将定义在头文件 <code>&lt;functional&gt;</code>，而不须更动到语言本身。</p>
<h3><span class="mw-headline" id=".E7.94.A8.E6.96.BC.E5.85.83.E7.B7.A8.E7.A8.8B.E7.9A.84.E5.9E.8B.E5.88.A5.E5.B1.AC.E6.80.A7">用于元编程的类别属性</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=45" title="编辑段落：用于元编程的类别属性">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>对于那些能自行创建或修改本身或其它程序的程序，我们称之为<a href="http://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B" title="元编程">元编程</a>。这种行为可以发生在编译或运行期。C++ 标准委员会已经决定引进一组由<a href="http://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF" title="模板">模板</a>实现的库，程序员可利用此一库于编译期进行元编程。</p>
<p>底下是一个以元编程来计算指数的例子:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw4">int</span> B, <span class="kw4">int</span> N<span class="sy1">&gt;</span>
<span class="kw4">struct</span> Pow <span class="br0">{</span>
    <span class="co1">// recursive call and recombination.</span>
    <span class="kw2">enum</span><span class="br0">{</span> value <span class="sy1">=</span> B<span class="sy2">*</span>Pow<span class="sy1">&lt;</span>B, N<span class="sy2">-</span><span class="nu0">1</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw2">template</span><span class="sy1">&lt;</span> <span class="kw4">int</span> B <span class="sy1">&gt;</span> 
<span class="kw4">struct</span> Pow<span class="sy1">&lt;</span>B, <span class="nu0">0</span><span class="sy1">&gt;</span> <span class="br0">{</span> 
    <span class="co1">// ''N == 0'' condition of termination.</span>
    <span class="kw2">enum</span><span class="br0">{</span> value <span class="sy1">=</span> <span class="nu0">1</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span> quartic_of_three <span class="sy1">=</span> Pow<span class="sy1">&lt;</span><span class="nu0">3</span>, <span class="nu0">4</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy4">;</span>
</pre></div>
</div>
<p>许多算法能作用在不同的数据类别; C++ 模板支持<a href="http://zh.wikipedia.org/wiki/%E6%B3%9B%E5%9E%8B" title="泛型">泛型</a>，这使得代码能更紧凑和有用。然而，算法经常会需要目前作用的数据类别的信息。这种信息可以通过类别属性 (<code>type traits</code>) 于模板实体化时将该信息萃取出来。</p>
<p>类别属性能识别一个对象的种类和有关一个类别 (class) (或 struct) 的特征。头文件 <code>&lt;type_traits&gt;</code> 描述了我们能识别那些特征。</p>
<p>底下的例子说明了模板函数‘elaborate’是如何根据给定的数据类别，从而实体化某一特定的算法 (<code>algorithm.do_it</code>)。</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="co1">// 演算法一</span>
<span class="kw2">template</span><span class="sy1">&lt;</span> <span class="kw4">bool</span> B <span class="sy1">&gt;</span> <span class="kw4">struct</span> Algorithm <span class="br0">{</span>
    <span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">class</span> T1, <span class="kw2">class</span> T2<span class="sy1">&gt;</span> <span class="kw4">static</span> <span class="kw4">int</span> do_it <span class="br0">(</span>T1 <span class="sy3">&amp;</span>, T2 <span class="sy3">&amp;</span><span class="br0">)</span>  <span class="br0">{</span> <span class="coMULTI">/*...*/</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="co1">// 演算法二</span>
<span class="kw2">template</span><span class="sy1">&lt;&gt;</span> <span class="kw4">struct</span> Algorithm<span class="sy1">&lt;</span><span class="kw2">true</span><span class="sy1">&gt;</span> <span class="br0">{</span>
    <span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">class</span> T1, <span class="kw2">class</span> T2<span class="sy1">&gt;</span> <span class="kw4">static</span> <span class="kw4">int</span> do_it <span class="br0">(</span>T1, T2<span class="br0">)</span>  <span class="br0">{</span> <span class="coMULTI">/*...*/</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="co1">// 根據給定的型別，實體化之後的 'elaborate' 會選擇演算法一或二</span>
<span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">class</span> T1, <span class="kw2">class</span> T2<span class="sy1">&gt;</span> 
<span class="kw4">int</span> elaborate <span class="br0">(</span>T1 A, T2 B<span class="br0">)</span> 
<span class="br0">{</span>
    <span class="co1">// 若 T1 為 int 且 T2 為 float，選用演算法二</span>
    <span class="co1">// 其它情況選用演算法一</span>
    <span class="kw1">return</span> Algorithm<span class="sy1">&lt;</span>std<span class="sy4">::</span><span class="me2">is_integral</span><span class="sy1">&lt;</span>T1<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span> <span class="sy3">&amp;&amp;</span> std<span class="sy4">::</span><span class="me2">is_floating_point</span><span class="sy1">&lt;</span>T2<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">do_it</span><span class="br0">(</span> A, B <span class="br0">)</span> <span class="sy4">;</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>通过定义在 <code>&lt;type_transform&gt;</code> 的类别属性，自定的类别转换是可能的 (在模板中，<code>static_cast</code> 和 <code>const_cast</code> 无法适用所有情况)。</p>
<p>此种编程技巧能写出优美、简洁的代码; 然而除错是此种编程技巧的弱处: 编译期的错误信息让人不知所云，运行期的除错更是困难。</p>
<h3><span class="mw-headline" id=".E7.94.A8.E4.BA.8E.E8.AE.A1.E7.AE.97.E5.87.BD.E6.95.B0.E5.AF.B9.E8.B1.A1.E8.BF.94.E5.9B.9E.E7.B1.BB.E5.9E.8B.E7.9A.84.E7.BB.9F.E4.B8.80.E6.96.B9.E6.B3.95">用于计算函数对象回返类型的统一方法</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=46" title="编辑段落：用于计算函数对象回返类型的统一方法">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>要在编译期决定一个样板仿函数的回返值类别并不容易，特别是当回返值依赖于函数的参数时。举例来说:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> Clear <span class="br0">{</span>
    <span class="kw4">int</span>    operator<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>     <span class="co1">// 參數與回返值的型別相同</span>
    <span class="kw4">double</span> operator<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// 參數與回返值的型別相同</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw2">template</span> <span class="sy1">&lt;</span><span class="kw2">class</span> Obj<span class="sy1">&gt;</span> 
<span class="kw2">class</span> Calculus <span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
    <span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">class</span> Arg<span class="sy1">&gt;</span> Arg operator<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span>Arg<span class="sy3">&amp;</span> a<span class="br0">)</span> <span class="kw4">const</span>
    <span class="br0">{</span>
        <span class="kw1">return</span> member<span class="br0">(</span>a<span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="kw2">private</span><span class="sy4">:</span>
    Obj member<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>实体化样板类 <code>Calculus&lt;Clear&gt;</code>，<code>Calculus</code> 的仿函数其回返值总是和 <code>Clear</code> 的仿函数其回返值具有相同的类别。然而，若给定类型 <code>Confused</code>:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw4">struct</span> Confused <span class="br0">{</span>
    <span class="kw4">double</span> operator<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>     <span class="co1">// 參數與回返值的型別不相同</span>
    <span class="kw4">int</span>    operator<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// 參數與回返值的型別不相同</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>企图实体化样板类 Calculus&lt;Confused&gt; 将导致 Calculus 的仿函数其回返值和类型 Confused 的仿函数其回返值有不同的类别。对于 <code>int</code> 和 <code>double</code> 之间的转换，编译器将给出警告。</p>
<p>模板 <code>std::result_of</code> 被TR1 引进且被 C++11 所采纳，可允许我们决定和使用一个仿函数其回返值的类别。底下，<code>CalculusVer2</code> 对象使用 <code>std::result_of</code> 对象来推导其仿函数的回返值类别:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="cpp source-cpp">
<pre class="de1"><span class="kw2">template</span><span class="sy1">&lt;</span> <span class="kw2">class</span> Obj <span class="sy1">&gt;</span>
<span class="kw2">class</span> CalculusVer2 <span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
    <span class="kw2">template</span><span class="sy1">&lt;</span><span class="kw2">class</span> Arg<span class="sy1">&gt;</span>
    <span class="kw2">typename</span> std<span class="sy4">::</span><span class="me2">result_of</span><span class="sy1">&lt;</span>Obj<span class="br0">(</span>Arg<span class="br0">)</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span> operator<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span>Arg<span class="sy3">&amp;</span> a<span class="br0">)</span> <span class="kw4">const</span>
    <span class="br0">{</span> 
        <span class="kw1">return</span> member<span class="br0">(</span>a<span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="kw2">private</span><span class="sy4">:</span>
    Obj member<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
</pre></div>
</div>
<p>如此一来，在实体化 <code>CalculusVer2&lt;Confused&gt;</code> 其仿函数时，不会有类别转换，警告或是错误发生。</p>
<p>模板 <code>std::result_of</code> 在 TR1 和 C++11 有一点不同。TR1 的版本允许实现在特殊情况下，可以无法决定一个函数调用其回返值类别。然而，因为 C++11支持了<a href="#.E5.9E.8B.E5.88.A5.E6.8E.A8.E5.B0.8E">decltype</a>，实现被要求在所有情况下，皆能计算出回返值类别。</p>
<h2><span class="mw-headline" id=".E5.B7.B2.E8.A2.AB.E7.A7.BB.E9.99.A4.E6.88.96.E6.98.AF.E4.B8.8D.E5.8C.85.E5.90.AB.E5.9C.A8_C.2B.2B11_.E6.A8.99.E6.BA.96.E7.9A.84.E7.89.B9.E8.89.B2">已被卸载或是不包含在 C++11 标准的特色</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=47" title="编辑段落：已被卸载或是不包含在 C++11 标准的特色">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>预计由 Technical Report 提供支持:</p>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2316.pdf">模块</a></li>
<li>十进制类别</li>
<li>数学专用函数</li>
</ul>
<p>延后讨论:</p>
<ul>
<li>Concepts (<a href="http://zh.wikipedia.org/wiki/%E6%A6%82%E5%BF%B5_%28C%2B%2B%29" title="概念 (C++)">概念 (C++)</a>)</li>
<li>更完整或必备的垃圾回收支持</li>
<li>Reflection</li>
<li>Macro Scopes</li>
</ul>
<h2><span class="mw-headline" id=".E8.A2.AB.E7.A7.BB.E9.99.A4.E6.88.96.E5.BB.A2.E6.A3.84.E7.9A.84.E7.89.B9.E8.89.B2">被卸载或废弃的特色</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=48" title="编辑段落：被卸载或废弃的特色">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li>循序点 (<a href="http://en.wikipedia.org/wiki/Sequence_point" class="extiw" title="en:Sequence point">sequence point</a>)，这个术语正被更为易懂的描述所取代。一个运算可以发生 (is sequenced before) 在另一个运算之前; 又或者两个运算彼此之间没有顺序关系 (are unsequenced)。</li>
<li><a href="http://en.wikipedia.org/wiki/export_%28C%2B%2B%29" class="extiw" title="en:export (C++)">export</a></li>
<li><a href="http://en.wikipedia.org/wiki/exception_specification" class="extiw" title="en:exception specification">exception specification</a>s</li>
<li><a href="http://en.wikipedia.org/wiki/std::auto_ptr" class="extiw" title="en:std::auto ptr">std::auto_ptr</a> 被 <b>std::unique_ptr</b> 取代。</li>
<li>仿函数基类别 (std::unary_function, std::binary_function)、函数指针适配器、类型成员指针适配器以及绑定器 (binder)。</li>
</ul>
<h2><span class="mw-headline" id=".E7.BC.96.E8.AF.91.E5.99.A8.E5.AE.9E.E7.8E.B0">编译器实现</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=49" title="编辑段落：编译器实现">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>C++编译器对C++11新特性的支持情况：</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/Visual_C%2B%2B" title="Visual C++" class="mw-redirect">Visual C++</a> 2010&nbsp;: <a rel="nofollow" class="external text" href="http://blogs.msdn.com/b/vcblog/archive/2010/04/06/c-0x-core-language-features-in-vc10-the-table.aspx">C++0x Core Language Features In VC10: The Table</a></li>
<li><a href="http://zh.wikipedia.org/wiki/Visual_C%2B%2B" title="Visual C++" class="mw-redirect">Visual C++</a> 2010与<a href="http://zh.wikipedia.org/wiki/Visual_C%2B%2B" title="Visual C++" class="mw-redirect">Visual C++</a> 2012支持的C++11特性的对比列表：<a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/vstudio/hh567368.aspx">C++11 Features (Modern C++)</a></li>
<li><a href="http://zh.wikipedia.org/wiki/GCC" title="GCC">GCC</a> 4.8.1已实现C++11标准的所有主要语言特性: <a rel="nofollow" class="external text" href="http://gcc.gnu.org/gcc-4.8/cxx0x_status.html">Status of Experimental C++11 Support in GCC 4.8</a></li>
</ul>
<h2><span class="mw-headline" id=".E9.97.9C.E8.81.AF.E9.A0.85.E7.9B.AE">关系项目</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=50" title="编辑段落：关系项目">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/C%2B%2B_Technical_Report_1" title="C++ Technical Report 1">C++ Technical Report 1</a></li>
<li><a href="http://zh.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80#C11" title="C语言" class="mw-redirect">C11</a>，C 编程语言的最新标准</li>
<li><a href="http://zh.wikipedia.org/wiki/C%2B%2B14" title="C++14">C++14</a>，计划中的 C++ 标准</li>
</ul>
<h2><span class="mw-headline" id=".E5.8F.83.E8.80.83.E8.B3.87.E6.96.99">参考资料</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=51" title="编辑段落：参考资料">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="reflist columns references-column-count references-column-count-2" style="column-count: 2; -moz-column-count: 2; -webkit-column-count: 2; list-style-type: decimal;">
<ol class="references">
<li id="cite_note-1"><b><a href="#cite_ref-1">^</a></b> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2544.pdf">N2544</a></span></li>
</ol>
</div>
<h3><span class="mw-headline" id="C.2B.2B.E6.A8.99.E6.BA.96.E5.A7.94.E5.93.A1.E6.9C.83.E6.96.87.E4.BB.B6">C++标准委员会文件</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=52" title="编辑段落：C++标准委员会文件">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li><span class="citation wikicite" id="endnote_n1401"><b><a href="#ref_n1401">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1401.pdf">1401</a>: Jan Kristoffersen (2002年10月21日) <i>Atomic operations with multi-threaded environments</i></li>
<li><span class="citation wikicite" id="endnote_n1402"><b><a href="#ref_n1402">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1402.html">1402</a>: Doug Gregor (2002年10月22日) <i>A Proposal to add a Polymorphic Function Object Wrapper to the Standard Library</i></li>
<li><span class="citation wikicite" id="endnote_n1403"><b><a href="#ref_n1403">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1403.pdf">1403</a>: Doug Gregor (2002年11月8日) <i>Proposal for adding tuple types into the standard library</i></li>
<li><span class="citation wikicite" id="endnote_n1424"><b><a href="#ref_n1424">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1424.htm">1424</a>: John Maddock (2003年3月3日) <i>A Proposal to add Type Traits to the Standard Library</i></li>
<li><span class="citation wikicite" id="endnote_n1429"><b><a href="#ref_n1429">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm">1429</a>: John Maddock (2003年3月3日) <i>A Proposal to add Regular Expression to the Standard Library</i></li>
<li><span class="citation wikicite" id="endnote_n1449"><b><a href="#ref_n1449">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1449.pdf">1449</a>: B. Stroustrup, G. Dos Reis, Mat Marcus, Walter E. Brown, Herb Sutter (2003年4月7日) <i>Proposal to add template aliases to C++</i></li>
<li><span class="citation wikicite" id="endnote_n1450"><b><a href="#ref_n1450">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1450.html">1450</a>: P. Dimov, B. Dawes, G. Colvin (2003年3月27日) <i>A Proposal to Add General Purpose Smart Pointers to the Library Technical Report (Revision 1)</i></li>
<li><span class="citation wikicite" id="endnote_n1452"><b><a href="#ref_n1452">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1452.html">1452</a>: Jens Maurer (April 10, 2003) <i>A Proposal to Add an Extensible Random Number Facility to the Standard Library (Revision 2)</i></li>
<li><span class="citation wikicite" id="endnote_n1453"><b><a href="#ref_n1453">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1453.html">1453</a>: D. Gregor, P. Dimov (April 9, 2003) <i>A proposal to add a reference wrapper to the standard library (revision 1)</i></li>
<li><span class="citation wikicite" id="endnote_n1454"><b><a href="#ref_n1454">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1454.html">1454</a>: Douglas Gregor, P. Dimov (April 9, 2003) <i>A uniform method for computing function object return types (revision 1)</i></li>
<li><span class="citation wikicite" id="endnote_n1456"><b><a href="#ref_n1456">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1456.html">1456</a>: Matthew Austern (April 9, 2003) <i>A Proposal to Add Hash Tables to the Standard Library (revision 4)</i></li>
<li><span class="citation wikicite" id="endnote_n1471"><b><a href="#ref_n1471">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1471.pdf">1471</a>: Daveed Vandevoorde (April 18, 2003) <i>Reflective Metaprogramming in C++</i></li>
<li><span class="citation wikicite" id="endnote_n1676"><b><a href="#ref_n1676">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1676.htm">1676</a>: Bronek Kozicki (September 9, 2004) <i>Non-member overloaded copy assignment operator</i></li>
<li><span class="citation wikicite" id="endnote_n1704"><b><a href="#ref_n1704">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1704.pdf">1704</a>: Douglas Gregor, Jaakko Järvi, Gary Powell (September 10, 2004) <i>Variadic Templates: Exploring the Design Space</i></li>
<li><span class="citation wikicite" id="endnote_n1705"><b><a href="#ref_n1705">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1705.pdf">1705</a>: J. Järvi, B. Stroustrup, D. Gregor, J. Siek, G. Dos Reis (September 12, 2004) <i>Decltype (and auto)</i></li>
<li><span class="citation wikicite" id="endnote_n1717"><b><a href="#ref_n1717">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1717.pdf">1717</a>: Francis Glassborow, Lois Goldthwaite (November 5, 2004) <i>explicit class and default definitions</i></li>
<li><span class="citation wikicite" id="endnote_n1719"><b><a href="#ref_n1719">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1719.pdf">1719</a>: Herb Sutter, David E. Miller (October 21, 2004) <i>Strongly Typed Enums (revision 1)</i></li>
<li><span class="citation wikicite" id="endnote_n1720"><b><a href="#ref_n1720">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html">1720</a>: R. Klarer, J. Maddock, B. Dawes, H. Hinnant (October 20, 2004) <i>Proposal to Add Static Assertions to the Core Language (Revision 3)</i></li>
<li><span class="citation wikicite" id="endnote_n1757"><b><a href="#ref_n1757">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html">1757</a>: Daveed Vandevoorde (January 14, 2005) <i>Right Angle Brackets (Revision 2)</i></li>
<li><span class="citation wikicite" id="endnote_n1811"><b><a href="#ref_n1811">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1811.pdf">1811</a>: J. Stephen Adamczyk (April 29, 2005) <i>Adding the long long type to C++ (Revision 3)</i></li>
<li><span class="citation wikicite" id="endnote_n1815"><b><a href="#ref_n1815">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1815.html">1815</a>: Lawrence Crowl (May 2, 2005) <i>ISO C++ Strategic Plan for Multithreading</i></li>
<li><span class="citation wikicite" id="endnote_n1827"><b><a href="#ref_n1827">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1827.htm">1827</a>: Chris Uzdavinis, Alisdair Meredith (August 29, 2005) <i>An Explicit Override Syntax for C++</i></li>
<li><span class="citation wikicite" id="endnote_n1834"><b><a href="#ref_n1834">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1834.html">1834</a>: Detlef Vollmann (June 24, 2005) <i>A Pleading for Reasonable Parallel Processing Support in C++</i></li>
<li><span class="citation wikicite" id="endnote_n1836"><b><a href="#ref_n1836">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf">1836</a>: ISO/IEC DTR 19768 (June 24, 2005) <i>Draft Technical Report on C++ Library Extensions</i></li>
<li><span class="citation wikicite" id="endnote_n1886"><b><a href="#ref_n1886">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1886.pdf">1886</a>: Gabriel Dos Reis, Bjarne Stroustrup (October 20, 2005) <i>Specifying C++ concepts</i></li>
<li><span class="citation wikicite" id="endnote_n1891"><b><a href="#ref_n1891">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1891.pdf">1891</a>: Walter E. Brown (October 18, 2005) <i>Progress toward Opaque Typedefs for C++0X</i></li>
<li><span class="citation wikicite" id="endnote_n1898"><b><a href="#ref_n1898">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1898.pdf">1898</a>: Michel Michaud, Michael Wong (October 6, 2004) <i>Forwarding and inherited constructors</i></li>
<li><span class="citation wikicite" id="endnote_n1919"><b><a href="#ref_n1919">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1919.pdf">1919</a>: Bjarne Stroustrup, Gabriel Dos Reis (December 11, 2005) <i>Initializer lists</i></li>
<li><span class="citation wikicite" id="endnote_n1968"><b><a href="#ref_n1968">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf">1968</a>: V Samko; J Willcock, J Järvi, D Gregor, A Lumsdaine (February 26, 2006) <i>Lambda expressions and closures for C++</i></li>
<li><span class="citation wikicite" id="endnote_n1986"><b><a href="#ref_n1986">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf">1986</a>: Herb Sutter, Francis Glassborow (April 6, 2006) <i>Delegating Constructors (revision 3)</i></li>
<li><span class="citation wikicite" id="endnote_n2016"><b><a href="#ref_n2016">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html">2016</a>: Hans Boehm, Nick Maclaren (April 21, 2002) <i>Should volatile Acquire Atomicity and Thread Visibility Semantics?</i></li>
<li><span class="citation wikicite" id="endnote_n2142"><b><a href="#ref_n2142">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2142.html">2142</a>: ISO/IEC DTR 19768 (January 12, 2007) <i>State of C++ Evolution (between Portland and Oxford 2007 Meetings)</i></li>
<li><span class="citation wikicite" id="endnote_n2228"><b><a href="#ref_n2228">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2228.html">2228</a>: ISO/IEC DTR 19768 (May 3, 2007) <i>State of C++ Evolution (Oxford 2007 Meetings)</i></li>
<li><span class="citation wikicite" id="endnote_n2258"><b><a href="#ref_n2258">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">2258</a>: G. Dos Reis and B. Stroustrup <i>Templates Aliases</i></li>
<li><span class="citation wikicite" id="endnote_n2280"><b><a href="#ref_n2280">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2280.html">2280</a>: Lawrence Crowl (May 2, 2007) <i>Thread-Local Storage</i></li>
<li><span class="citation wikicite" id="endnote_n2291"><b><a href="#ref_n2291">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2291.html">2291</a>: ISO/IEC DTR 19768 (June 25, 2007) <i>State of C++ Evolution (Toronto 2007 Meetings)</i></li>
<li><span class="citation wikicite" id="endnote_n2336"><b><a href="#ref_n2336">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2336.html">2336</a>: ISO/IEC DTR 19768 (July 29, 2007) <i>State of C++ Evolution (Toronto 2007 Meetings)</i></li>
<li><span class="citation wikicite" id="endnote_n2389"><b><a href="#ref_n2389">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2389.html">2389</a>: ISO/IEC DTR 19768 (August 7, 2007) <i>State of C++ Evolution (pre-Kona 2007 Meetings)</i></li>
<li><span class="citation wikicite" id="endnote_n2431"><b><a href="#ref_n2431">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf">2431</a>: SC22/WG21/N2431 = J16/07-0301 (October 2, 2007), <i>A name for the null pointer: nullptr</i></li>
<li><span class="citation wikicite" id="endnote_n2432"><b><a href="#ref_n2432">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2432.html">2432</a>: ISO/IEC DTR 19768 (October 23, 2007) <i>State of C++ Evolution (post-Kona 2007 Meeting)</i></li>
<li><span class="citation wikicite" id="endnote_n2437"><b><a href="#ref_n2437">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2437.pdf">2437</a>: Lois Goldthwaite (October 5, 2007) <i>Explicit Conversion Operators</i></li>
<li><span class="citation wikicite" id="endnote_n2461"><b><a href="#ref_n2461">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">2461</a>: ISO/IEC DTR 19768 (October 22, 2007) <i>Working Draft, Standard for programming Language C++</i></li>
<li><span class="citation wikicite" id="endnote_n2507"><b><a href="#ref_n2507">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2507.html">2507</a>: ISO/IEC DTR 19768 (February 4, 2008) <i>State of C++ Evolution (pre-Bellevue 2008 Meeting)</i></li>
<li><span class="citation wikicite" id="endnote_n2544"><b><a href="#ref_n2544">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2544.pdf">2544</a>: Alan Talbot, Lois Goldthwaite, Lawrence Crowl, Jens Maurer (February 29, 2008) <i>Unrestricted unions</i></li>
<li><span class="citation wikicite" id="endnote_n2565"><b><a href="#ref_n2565">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2565.html">2565</a>: ISO/IEC DTR 19768 (March 7, 2008) <i>State of C++ Evolution (post-Bellevue 2008 Meeting)</i></li>
<li><span class="citation wikicite" id="endnote_n2597"><b><a href="#ref_n2597">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2597.html">2597</a>: ISO/IEC DTR 19768 (April 29, 2008) <i>State of C++ Evolution (pre-Antipolis 2008 Meeting)</i></li>
<li><span class="citation wikicite" id="endnote_n2606"><b><a href="#ref_n2606">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2606.pdf">2606</a>: ISO/IEC DTR 19768 (May 19, 2008) <i>Working Draft, Standard for Programming Language C++</i></li>
<li><span class="citation wikicite" id="endnote_n2697"><b><a href="#ref_n2697">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2697.html">2697</a>: ISO/IEC DTR 19768 (June 15, 2008) <i>Minutes of WG21 Meeting June 8–15, 2008</i></li>
<li><span class="citation wikicite" id="endnote_n2798"><b><a href="#ref_n2798">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">2798</a>: ISO/IEC DTR 19768 (October 4, 2008) <i>Working Draft, Standard for Programming Language C++</i></li>
<li><span class="citation wikicite" id="endnote_n2857"><b><a href="#ref_n2857">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">2857</a>: ISO/IEC DTR 19768 (March 23, 2009) <i>Working Draft, Standard for Programming Language C++</i></li>
<li><span class="citation wikicite" id="endnote_n2869"><b><a href="#ref_n2869">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2869.html">2869</a>: ISO/IEC DTR 19768 (April 28, 2009) <i>State of C++ Evolution (post-San Francisco 2008 Meeting)</i></li>
<li><span class="citation wikicite" id="endnote_n3000"><b><a href="#ref_n3000">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n3000.pdf">3000</a>: ISO/ISC DTR 19769 (November 9, 2009) <i>Working Draft, Standard for Programming Language C++</i></li>
<li><span class="citation wikicite" id="endnote_n3014"><b><a href="#ref_n3014">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3014.pdf">3014</a>: Stephen D. Clamage (November 4, 2009) <i>AGENDA, PL22.16 Meeting No. 53, WG21 Meeting No. 48, March 8–13, 2010, Pittsburgh, PA</i></li>
<li><span class="citation wikicite" id="endnote_n3082"><b><a href="#ref_n3082">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3082.pdf">3082</a>: Herb Sutter (2010年3月13日) <i>C++0x Meeting Schedule</i></li>
<li><span class="citation wikicite" id="endnote_n3092"><b><a href="#ref_n3092">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf">3092</a>: ISO/ISC DTR 19769 (2010年3月26日) <i>Working Draft, Standard for Programming Language C++</i></li>
<li><span class="citation wikicite" id="endnote_n3126"><b><a href="#ref_n3126">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3126.pdf">3126</a>: ISO/ISC DTR 19769 (2010年8月21日) <i>Working Draft, Standard for Programming Language C++</i></li>
<li><span class="citation wikicite" id="endnote_n3225"><b><a href="#ref_n3225">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3225.pdf">3225</a>: ISO/ISC DTR 19769 (2010年11月27日) <i>Working Draft, Standard for Programming Language C++</i></li>
<li><span class="citation wikicite" id="endnote_n3242"><b><a href="#ref_n3242">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">3242</a>: ISO/ISC DTR 19769 (2011年2月28日) <i>Working Draft, Standard for Programming Language C++</i></li>
<li><span class="citation wikicite" id="endnote_n3290"><b><a href="#ref_n3290">^</a></b></span> Doc No. <a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3290.pdf">3290</a>: ISO/ISC DTR 19769 (2011年4月11日) <i>Working Draft, Standard for Programming Language C++</i></li>
</ul>
<h3><span class="mw-headline" id=".E6.96.87.E7.AB.A0">文章</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=53" title="编辑段落：文章">编辑</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul>
<li><span class="citation wikicite" id="endnote_strousup-brieflooka"><a href="#ref_strousup-brieflooka"><b><sup>a</sup></b></a></span> <span class="citation wikicite" id="endnote_strousup-brieflookb"><a href="#ref_strousup-brieflookb"><b><sup>b</sup></b></a></span> The C++ Source Bjarne Stroustrup(2006年1月2日)<i>A Brief Look at C++0x</i></li>
<li><span class="citation wikicite" id="endnote_strousup-designof"><b><a href="#ref_strousup-designof">^</a></b></span> C/C++ Users Journal Bjarne Stroustrup (May, 2005) <i>The Design of C++0x: Reinforcing C++’s proven strengths, while moving into the future</i></li>
<li>Web Log di Raffaele Rialdi(2005年9月16日)<i>Il futuro di C++ raccontato da Herb Sutter</i></li>
<li><a href="http://zh.wikipedia.org/w/index.php?title=Informit.com&amp;action=edit&amp;redlink=1" class="new" title="Informit.com（页面不存在）">Informit.com</a>(2006年8月5日)<i>The Explicit Conversion Operators Proposal</i></li>
<li>Informit.com(2006年7月25日)<i>Introducing the Lambda Library</i></li>
<li>Dr. Dobb's Portal Pete Becker(2006年4月11日)<i>Regular Expressions TR1's regex implementation</i></li>
<li>Informit.com(2006年7月25日)<i>The Type Traits Library</i></li>
<li>Dr. Dobb's Portal Pete Becker(2005年5月11日)<i>C++ Function Objects in TR1</i></li>
<li>The C++ Source Howard E. Hinnant, Bjarne Stroustrup, and Bronek Kozicki(2008年3月10日)<a rel="nofollow" class="external text" href="http://www.artima.com/cppsource/rvalue.html">A Brief Introduction to Rvalue References</a></li>
<li>DevX.com Special Report(2008年8月18日)<a rel="nofollow" class="external text" href="http://www.devx.com/SpecialReports/Door/38865">C++0x: The Dawning of a New Standard</a></li>
</ul>
<h2><span class="mw-headline" id=".E5.A4.96.E9.83.A8.E9.80.A3.E7.B5.90">外部链接</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit&amp;section=54" title="编辑段落：外部链接">编辑</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul>
<li><a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/"><b>The C++ Standards</b> Committee</a></li>
<li><a rel="nofollow" class="external text" href="http://www.research.att.com/%7Ebs/">Bjarne Stroustrup's homepage</a></li>
<li><a rel="nofollow" class="external text" href="http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=216">C++0X: The New Face of Standard C++</a></li>
<li><a rel="nofollow" class="external text" href="http://herbsutter.wordpress.com/">Herb Sutter's blog coverage of C++0X</a></li>
<li><a rel="nofollow" class="external text" href="http://www.csclub.uwaterloo.ca/media/C++0x%20-%20An%20Overview.html">A talk on C++0x given by Bjarne Stroustrup at the University of Waterloo</a></li>
<li><a rel="nofollow" class="external text" href="http://www.pvv.org/%7Eoma/cpp0x_aquadi_nov_2007.pdf">A quick and dirty introduction to C++0x (as of November 2007)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.devx.com/SpecialReports/Article/38813/0/page/1">The State of the Language: An Interview with Bjarne Stroustrup (August 15, 2008)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">Working draft for the C++ language, October 4, 2008</a></li>
</ul>


<!-- 
NewPP limit report
Parsed by mw1174
CPU time usage: 2.856 seconds
Real time usage: 2.925 seconds
Preprocessor visited node count: 2167/1000000
Preprocessor generated node count: 7116/1500000
Post‐expand include size: 98957/2048000 bytes
Template argument size: 1285/2048000 bytes
Highest expansion depth: 10/40
Expensive parser function count: 1/500
Lua time usage: 0.023/10.000 seconds
Lua memory usage: 1.36 MB/50 MB
-->

<!-- Saved in parser cache with key zhwiki:pcache:idhash:972235-0!*!0!!zh-cn!4!zh-cn!* and timestamp 20140801050334 and revision id 32096808
 -->
<noscript><img src="//zh.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" /></noscript></div>									<div class="printfooter">
						取自“<a dir="ltr" href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;oldid=32096808">http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;oldid=32096808</a>”					</div>
													<div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="http://zh.wikipedia.org/wiki/Special:%E9%A1%B5%E9%9D%A2%E5%88%86%E7%B1%BB" title="Special:页面分类">分类</a>：<ul><li><a href="http://zh.wikipedia.org/wiki/Category:C%2B%2B" title="Category:C++">C++</a></li><li><a href="http://zh.wikipedia.org/wiki/Category:%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%E6%A8%99%E6%BA%96" title="Category:程式語言標準">编程语言标准</a></li></ul></div><div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">隐藏分类：<ul><li><a href="http://zh.wikipedia.org/wiki/Category:%E8%87%AA2009%E5%B9%B44%E6%9C%88%E6%9C%89%E6%9C%AA%E5%88%97%E6%98%8E%E6%9D%A5%E6%BA%90%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9D%A1%E7%9B%AE" title="Category:自2009年4月有未列明来源语句的条目">自2009年4月有未列明来源语句的条目</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>导航菜单</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">个人工具</h3>
						<ul dir="ltr" lang="zh-CN">
							<li id="pt-createaccount"><a href="http://zh.wikipedia.org/w/index.php?title=Special:%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95&amp;returnto=C%2B%2B11&amp;type=signup">创建账户</a></li><li id="pt-login"><a href="http://zh.wikipedia.org/w/index.php?title=Special:%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95&amp;returnto=C%2B%2B11" title="建议你登录，尽管并非必须。[Alt+Shift+o]" accesskey="o">登录</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">名字空间</h3>
						<ul dir="ltr" lang="zh-CN">
															<li id="ca-nstab-main" class="selected"><span><a href="http://zh.wikipedia.org/wiki/C%2B%2B11" title="浏览条目正文[Alt+Shift+c]" accesskey="c">条目</a></span></li>
															<li id="ca-talk"><span><a href="http://zh.wikipedia.org/wiki/Talk:C%2B%2B11" title="关于此页面的讨论[Alt+Shift+t]" accesskey="t">讨论</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu" aria-labelledby="p-variants-label">
												<h3 tabindex="0" id="p-variants-label"><span style="display: block;">大陆简体</span><a tabindex="-1" href="#"></a></h3>

						<div class="menu">
							<ul>
																	<li id="ca-varlang-0"><a href="http://zh.wikipedia.org/zh/C%2B%2B11" hreflang="zh" lang="zh">不转换</a></li>
																	<li id="ca-varlang-1"><a href="http://zh.wikipedia.org/zh-hans/C%2B%2B11" hreflang="zh-Hans" lang="zh-Hans">简体</a></li>
																	<li id="ca-varlang-2"><a href="http://zh.wikipedia.org/zh-hant/C%2B%2B11" hreflang="zh-Hant" lang="zh-Hant">繁體</a></li>
																	<li id="ca-varlang-3" class="selected"><a href="http://zh.wikipedia.org/zh-cn/C%2B%2B11" hreflang="zh-CN" lang="zh-CN">大陆简体</a></li>
																	<li id="ca-varlang-4"><a href="http://zh.wikipedia.org/zh-hk/C%2B%2B11" hreflang="zh-HK" lang="zh-HK">香港繁體</a></li>
																	<li id="ca-varlang-5"><a href="http://zh.wikipedia.org/zh-mo/C%2B%2B11" hreflang="zh-MO" lang="zh-MO">澳門繁體</a></li>
																	<li id="ca-varlang-6"><a href="http://zh.wikipedia.org/zh-sg/C%2B%2B11" hreflang="zh-SG" lang="zh-SG">马新简体</a></li>
																	<li id="ca-varlang-7"><a href="http://zh.wikipedia.org/zh-tw/C%2B%2B11" hreflang="zh-TW" lang="zh-TW">台灣正體</a></li>
															</ul>
						</div>
					</div><div style="cursor: pointer;" class="metadata topicon noprint nopopups noteTA-topicon vectorTabs" title="本页使用了标题或全文手工转换" id="noteTA-topicon-45218"><ul><li><span><a href="#"><span style="padding:1px 3px; background: #d3e3f4; color:#000000;">汉</span><span style="padding:1px 3px; background: #e9e9e9; color:#434343;">漢</span></a></span></li></ul></div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">查看</h3>
						<ul dir="ltr" lang="zh-CN">
															<li id="ca-view" class="selected"><span><a href="http://zh.wikipedia.org/wiki/C%2B%2B11">阅读</a></span></li>
															<li id="ca-edit"><span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=edit" title="你可以编辑本页面。请在保存前使用预览按钮[Alt+Shift+e]" accesskey="e">编辑</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=history" title="本页面的早前版本。[Alt+Shift+h]" accesskey="h">查看历史</a></span></li>
													</ul>
					</div>
										<div style="" id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 tabindex="0" id="p-cactions-label"><span>更多</span><a tabindex="-1" href="#"></a></h3>

						<div class="menu">
							<ul dir="ltr" lang="zh-CN">
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3 dir="ltr" lang="zh-CN">
							<label for="searchInput">搜索</label>
						</h3>

						<form action="/w/index.php" id="searchform">
														<div id="simpleSearch">
															<input autocomplete="off" tabindex="1" name="search" placeholder="搜索" title="搜索维基百科[Alt+Shift+f]" accesskey="f" id="searchInput" type="search"><input value="Special:搜索" name="title" type="hidden"><input name="go" value="前往" title="如果相同的标题存在的话便直接前往该页面" id="searchButton" class="searchButton" type="submit">								</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a style="background-image: url(//upload.wikimedia.org/wikipedia/zh/b/bc/Wiki.png);" href="http://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5" title="首页"></a></div>
						<div class="portal first" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 dir="ltr" id="p-navigation-label" lang="zh-CN">导航</h3>

			<div class="body">
									<ul>
													<li id="n-mainpage-description"><a href="http://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5" title="访问首页[Alt+Shift+z]" accesskey="z">首页</a></li>
													<li id="n-indexpage"><a href="http://zh.wikipedia.org/wiki/Wikipedia:%E5%88%86%E7%B1%BB%E7%B4%A2%E5%BC%95" title="以分类索引搜寻中文维基百科">分类索引</a></li>
													<li id="n-Featured_content"><a href="http://zh.wikipedia.org/wiki/Portal:%E7%89%B9%E8%89%B2%E5%85%A7%E5%AE%B9" title="查看中文维基百科的特色内容">特色内容</a></li>
													<li id="n-currentevents"><a href="http://zh.wikipedia.org/wiki/Portal:%E6%96%B0%E8%81%9E%E5%8B%95%E6%85%8B" title="提供当前新闻事件的背景资料">新闻动态</a></li>
													<li id="n-recentchanges"><a href="http://zh.wikipedia.org/wiki/Special:%E6%9C%80%E8%BF%91%E6%9B%B4%E6%94%B9" title="列出维基百科中的最近修改[Alt+Shift+r]" accesskey="r">最近更改</a></li>
													<li id="n-randompage"><a href="http://zh.wikipedia.org/wiki/Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2" title="随机载入一个页面[Alt+Shift+x]" accesskey="x">随机条目</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-help" aria-labelledby="p-help-label">
			<h3 dir="ltr" id="p-help-label" lang="zh-CN">帮助</h3>

			<div class="body">
									<ul>
													<li id="n-help"><a href="http://zh.wikipedia.org/wiki/Help:%E7%9B%AE%E5%BD%95" title="寻求帮助">帮助</a></li>
													<li id="n-portal"><a href="http://zh.wikipedia.org/wiki/Wikipedia:%E7%A4%BE%E5%8C%BA%E4%B8%BB%E9%A1%B5" title="关于本计划、你可以做什么、应该如何做">社区专页</a></li>
													<li id="n-policy"><a href="http://zh.wikipedia.org/wiki/Wikipedia:%E6%96%B9%E9%87%9D%E8%88%87%E6%8C%87%E5%BC%95" title="查看维基百科的方针和指引">方针与指引</a></li>
													<li id="n-villagepump"><a href="http://zh.wikipedia.org/wiki/Wikipedia:%E4%BA%92%E5%8A%A9%E5%AE%A2%E6%A0%88" title="参与维基百科社群的讨论">互助客栈</a></li>
													<li id="n-Information_desk"><a href="http://zh.wikipedia.org/wiki/Wikipedia:%E7%9F%A5%E8%AF%86%E9%97%AE%E7%AD%94" title="解答任何与维基百科无关的问题的地方">知识问答</a></li>
													<li id="n-conversion"><a href="http://zh.wikipedia.org/wiki/Wikipedia:%E5%AD%97%E8%AF%8D%E8%BD%AC%E6%8D%A2%E8%AF%B7%E6%B1%82%E6%88%96%E5%80%99%E9%80%89" title="提出字词转换请求">字词转换</a></li>
													<li id="n-IRC"><a href="http://zh.wikipedia.org/wiki/Wikipedia:IRC%E8%81%8A%E5%A4%A9%E9%A2%91%E9%81%93/IRC?withJS=MediaWiki:Gadget-irc.js">IRC即时聊天</a></li>
													<li id="n-contact"><a href="http://zh.wikipedia.org/wiki/Wikipedia:%E8%81%94%E7%B3%BB%E6%88%91%E4%BB%AC" title="如何联络维基百科">联系我们</a></li>
													<li id="n-about"><a href="http://zh.wikipedia.org/wiki/Wikipedia:%E5%85%B3%E4%BA%8E" title="查看维基百科的简介">关于维基百科</a></li>
													<li id="n-sitesupport"><a href="http://donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&amp;utm_medium=sidebar&amp;utm_campaign=C13_zh.wikipedia.org&amp;uselang=zh" title="如果您在维基百科受益良多，您可以考虑资助我们">资助维基百科</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 dir="ltr" id="p-tb-label" lang="zh-CN">工具</h3>

			<div class="body">
									<ul>
													<li id="t-whatlinkshere"><a href="http://zh.wikipedia.org/wiki/Special:%E9%93%BE%E5%85%A5%E9%A1%B5%E9%9D%A2/C%2B%2B11" title="列出所有与本页相链的页面[Alt+Shift+j]" accesskey="j">链入页面</a></li>
													<li id="t-recentchangeslinked"><a href="http://zh.wikipedia.org/wiki/Special:%E9%93%BE%E5%87%BA%E6%9B%B4%E6%94%B9/C%2B%2B11" title="页面链出所有页面的更改[Alt+Shift+k]" accesskey="k">相关更改</a></li>
													<li id="t-upload"><a href="http://zh.wikipedia.org/wiki/Project:%E4%B8%8A%E4%BC%A0" title="上传图像或多媒体文件[Alt+Shift+u]" accesskey="u">上传文件</a></li>
													<li id="t-specialpages"><a href="http://zh.wikipedia.org/wiki/Special:%E7%89%B9%E6%AE%8A%E9%A1%B5%E9%9D%A2" title="全部特殊页面的列表[Alt+Shift+q]" accesskey="q">特殊页面</a></li>
													<li id="t-print"><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;printable=yes" rel="alternate" title="本页面的可打印版本[Alt+Shift+p]" accesskey="p">打印版本</a></li>
													<li id="t-permalink"><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;oldid=32096808" title="本页面该版本的固定链接">固定链接</a></li>
													<li id="t-info"><a href="http://zh.wikipedia.org/w/index.php?title=C%2B%2B11&amp;action=info">页面信息</a></li>
													<li id="t-wikibase"><a href="http://www.wikidata.org/wiki/Q1061570" title="查看连接的数据存储库项[Alt+Shift+g]" accesskey="g">维基数据项</a></li>
						<li id="t-cite"><a href="http://zh.wikipedia.org/w/index.php?title=Special:%E5%BC%95%E7%94%A8&amp;page=C%2B%2B11&amp;id=32096808" title="关于如何引用本页的信息">引用本页</a></li>					<li id="t-topbottomlink"><a href="javascript:void(0);" title="在画面左上角及左下角显示跳至页顶和页底的连接">左侧跳顶连接</a></li></ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-lang" aria-labelledby="p-lang-label"><span original-title="语言设置" aria-haspopup="true" role="button" tabindex="0" class="uls-settings-trigger"></span>
			<h3 dir="ltr" id="p-lang-label" lang="zh-CN">其他语言</h3>

			<div class="body">
									<ul>
													<li class="interlanguage-link interwiki-cs"><a href="http://cs.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 捷克文" hreflang="cs" lang="cs">Čeština</a></li>
													<li class="interlanguage-link interwiki-en"><a href="http://en.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 英文" hreflang="en" lang="en">English</a></li>
													<li class="interlanguage-link interwiki-es"><a href="http://es.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 西班牙文" hreflang="es" lang="es">Español</a></li>
													<li class="interlanguage-link interwiki-fi"><a href="http://fi.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 芬兰文" hreflang="fi" lang="fi">Suomi</a></li>
													<li class="interlanguage-link interwiki-fr"><a href="http://fr.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 法文" hreflang="fr" lang="fr">Français</a></li>
													<li class="interlanguage-link interwiki-it"><a href="http://it.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 意大利文" hreflang="it" lang="it">Italiano</a></li>
													<li class="interlanguage-link interwiki-ja"><a href="http://ja.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 日文" hreflang="ja" lang="ja">日本語</a></li>
													<li class="interlanguage-link interwiki-ko"><a href="http://ko.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 韩文" hreflang="ko" lang="ko">한국어</a></li>
													<li class="interlanguage-link interwiki-pl"><a href="http://pl.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 波兰文" hreflang="pl" lang="pl">Polski</a></li>
													<li class="interlanguage-link interwiki-pt"><a href="http://pt.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 葡萄牙文" hreflang="pt" lang="pt">Português</a></li>
													<li class="interlanguage-link interwiki-ru"><a href="http://ru.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 俄文" hreflang="ru" lang="ru">Русский</a></li>
													<li class="interlanguage-link interwiki-sr"><a href="http://sr.wikipedia.org/wiki/%D0%9D%D0%B0%D1%86%D1%80%D1%82_C%2B%2B0x_%D0%BE%D0%B4_%D0%BC%D0%B0%D1%80%D1%82%D0%B0_2010." title="Нацрт C++0x од марта 2010. – 塞尔维亚文" hreflang="sr" lang="sr">Српски / srpski</a></li>
													<li class="interlanguage-link interwiki-th"><a href="http://th.wikipedia.org/wiki/%E0%B8%A0%E0%B8%B2%E0%B8%A9%E0%B8%B2%E0%B8%8B%E0%B8%B5%E0%B8%9E%E0%B8%A5%E0%B8%B1%E0%B8%AA%E0%B8%9E%E0%B8%A5%E0%B8%B1%E0%B8%AA%E0%B9%82%E0%B8%AD%E0%B9%80%E0%B8%AD%E0%B8%81%E0%B8%8B%E0%B9%8C" title="ภาษาซีพลัสพลัสโอเอกซ์ – 泰文" hreflang="th" lang="th">ไทย</a></li>
													<li class="interlanguage-link interwiki-uk"><a href="http://uk.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 乌克兰文" hreflang="uk" lang="uk">Українська</a></li>
													<li class="interlanguage-link interwiki-vi"><a href="http://vi.wikipedia.org/wiki/C%2B%2B11" title="C++11 – 越南文" hreflang="vi" lang="vi">Tiếng Việt</a></li>
													
											</ul>
				<div class="after-portlet after-portlet-lang"><span class="wb-langlinks-edit wb-langlinks-link"><a action="edit" href="http://www.wikidata.org/wiki/Q1061570#sitelinks-wikipedia" text="编辑链接" title="编辑跨语言链接" class="wbc-editpage">编辑链接</a></span></div>			</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo" dir="ltr" lang="zh-CN">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> 本页面最后修订于2014年8月1日 (星期五) 05:03。<br></li>
											<li id="footer-info-copyright">本站的全部文字在<a rel="license" href="http://zh.wikipedia.org/zh-cn/Wikipedia%3ACC-BY-SA-3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" title="Wikipedia:CC-BY-SA-3.0协议文本">知识共享 署名-相同方式共享 3.0协议</a><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.zh" style="display:none;"></a>之条款下提供，附加条款亦可能应用。（请参阅<a href="http://wikimediafoundation.org/wiki/%E4%BD%BF%E7%94%A8%E6%9D%A1%E6%AC%BE">使用条款</a>）<br>
Wikipedia®和维基百科标志是<a href="http://wikimediafoundation.org/">维基媒体基金会</a>的注册商标；维基™是维基媒体基金会的商标。<br>维基媒体基金会是在美国佛罗里达州登记的501(c)(3)<a href="http://wikimediafoundation.org/wiki/%E8%B5%84%E5%8A%A9%E7%9A%84%E5%85%8D%E7%A8%8E%E6%94%BF%E7%AD%96">免税</a>、非营利、慈善机构。<br></li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="http://wikimediafoundation.org/wiki/%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96" title="wikimedia:隐私政策">隐私权政策</a></li>
											<li id="footer-places-about"><a href="http://zh.wikipedia.org/wiki/Wikipedia:%E5%85%B3%E4%BA%8E" title="Wikipedia:关于">关于维基百科</a></li>
											<li id="footer-places-disclaimer"><a href="http://zh.wikipedia.org/wiki/Wikipedia:%E5%85%8D%E8%B4%A3%E5%A3%B0%E6%98%8E" title="Wikipedia:免责声明">免责声明</a></li>
											<li id="footer-places-developers"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute">开发者</a></li>
											<li id="footer-places-mobileview"><a href="http://zh.m.wikipedia.org/wiki/C%2B%2B11" class="noprint stopMobileRedirectToggle">移动版视图</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
															<a href="http://wikimediafoundation.org/"><img src="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/wikimedia-button.png" alt="Wikimedia Foundation" height="31" width="88"></a>
													</li>
											<li id="footer-poweredbyico">
															<a href="http://www.mediawiki.org/"><img src="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" height="31" width="88"></a>
													</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["ext.cite","mediawiki.toc","mobile.desktop","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","ext.gadget.edit0","ext.gadget.WikiMiniAtlas","ext.gadget.ReferenceTooltips","ext.gadget.UnihanTooltips","ext.gadget.FixedTopBottomLink","ext.gadget.AdvancedSiteNotices","ext.gadget.hideConversionTab","ext.gadget.internalLinkHelper-altcolor","ext.gadget.noteTA","ext.gadget.noteTAvector","ext.gadget.NavFrame","ext.gadget.collapsibleTables","mmv.bootstrap.autostart","ext.eventLogging.subscriber","ext.navigationTiming","schema.UniversalLanguageSelector","ext.uls.eventlogger","ext.uls.interlanguage"],null,true);
}</script>
<script src="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/index.php"></script>
<script src="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/index_003.php"></script>
<script src="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/index_004.php"></script>
<script src="C++11%20-%20%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%EF%BC%8C%E8%87%AA%E7%94%B1%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6_files/load.php"></script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":535,"wgHostname":"mw1032"});
}</script>
	

	<div class="suggestions" style="display: none; font-size: 13px;"><div class="suggestions-results"></div><div class="suggestions-special"></div></div><div class="noprint topbottomScrollTag" style="top: 0px; display: none;" title="跳至页顶"><div style="position: fixed; width: 1em; top: 5px; text-align: center; text-decoration: overline; display: none;">↑</div></div><div class="noprint topbottomScrollTag" style="bottom: 0px; display: none;" title="跳至页底"><div style="position: fixed; width: 1em; bottom: 5px; text-align: center; text-decoration: underline; display: none;">↓</div></div><div class="noprint topbottomScrollTag" id="btnCloseTopbottom0" style="left: 1em; top: 0px; width: 1em; height: 1em; padding: 3px; display: none;" title="隐藏跳至页顶和页底的连接"><div style="display: none;">╳</div></div><div style="left: 0px; top: 0px; position: absolute; width: 29px; height: 27px; border: medium none; margin: 0px; padding: 0px; z-index: 2147483647; display: none;" class="sbi_search" id="sbi_camera_button"></div></body></html>