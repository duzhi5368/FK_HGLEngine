Read与ReadFully

	在大多数情况下，Read与ReadFully是相同的。但当我们从一些特殊接口读取数据时，有可能并无法得到我们想要
的完整数据流。比如网络。

	比如我们要求读取1024个字节的数据，但网卡缓冲区中现在只有512个字节。那么Read(buf,1024)会立即返回512，
告之开发者仅成功读取了512个字节。而ReadFully会不断的进行读取，直到读满1024个字节或是出现网络错误为止。当
然，超时错误它会无视。

	Write与WriteFully的情况同理。

	为什么要引入ReadFull/WriteFully呢？在Java的I/O库中也有同样的定义，起初我也并不明白这种命名的含义。
不过会期发现，其原因在于我们定义的DataInputStream/DataOutputStream经常需要指定一个数据类型的写入数据。
而在这种情况下，还处理只写入了一半会相当的麻烦，于是就需要一个能够保证写入和读出的API。

	所以，当我们在按类型，必须写入或读取指定长度的数据时，请使用WriteFully/ReadFully。而在将一个缓冲写
入或读取，可以不一次处理完时，使用Write/Read。

